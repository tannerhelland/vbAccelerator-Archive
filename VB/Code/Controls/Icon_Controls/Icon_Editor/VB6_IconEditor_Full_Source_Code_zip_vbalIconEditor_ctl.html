<html lang="en" >

<!-- Mirrored from www.vbaccelerator.com/home/VB/Code/Controls/Icon_Controls/Icon_Editor/VB6_IconEditor_Full_Source_Code_zip_vbalIconEditor_ctl.asp by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 Jun 2015 21:30:54 GMT -->
<head>
<title>vbAccelerator - Contents of code file: vbalIconEditor.ctl</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta name="AUTHOR" content="Steve McMahon" /><meta name="KEYWORDS" content=".NET, .NET Framework, C#, CSharp, VB, Visual Basic, VB5, VB6, Visual Basic, Active X, Controls, Components" /><meta name="DESCRIPTION" content="vbAccelerator - Contents of code file: vbalIconEditor.ctl" /><link rel="stylesheet" href="../../../../../res/screen.css" media="SCREEN" /><link rel="stylesheet" href="../../../../../res/print.css" media="PRINT" /></head><body>
<table>
<tr class="adbar" bgcolor="#83726a"><tr class="footer"><td></td>
<td>
<p class="center">

<script type="text/javascript"><!--
google_ad_client = "pub-4690375644913255";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_channel ="";
google_ad_type = "text_image";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_url = "008000.html";
google_color_text = "000000";
//--></script>
<script type="text/javascript"
  src="../../../../../../../pagead2.googlesyndication.com/pagead/f.txt">
</script>
</p>
</td>
<td></td>
</tr></tr><tr class="navbar"><td><a href="http://www.vbaccelerator.com/home/index.asp"><img width="125" height="25" src="../../../../../res/vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="http://www.vbaccelerator.com/home/index.asp">Home</a>&#160;.&#160;<a href="../../../../index.html">VB</a>&#160;.&#160;<a href="../../../index.html">Code</a>&#160;.&#160;<a href="../../index.html">Controls</a>&#160;.&#160;<a href="../index.html">Icon Controls</a>&#160;.&#160;<a href="article.html">vbAccelerator Icon Editor Control</a>&#160;.&#160;<a href="VB6_IconEditor_Full_Source_Code.html">VB6 IconEditor Full Source Code</a>&#160;.&#160;vbalIconEditor.ctl</p></td><td></td></tr><tr class="navbar"><td colspan="3"><hr /></td></tr><tr valign="top"><td class="sidebar"><img src="../../../../../res/download.png" width="125" height="21" alt="Downloads" /><p class="nav"><a href="IconEditor_Documentation.html"><img src="../../../../../res/get.png" width="8" height="8" alt="Download Page" />IconEditor Documentation</a> (1K)</p><p /><p class="nav"><a href="VB5_IconEditor_Demonstration.html"><img src="../../../../../res/get.png" width="8" height="8" alt="Download Page" />VB5 IconEditor Demonstration</a> (126K)</p><p class="nav"><a href="VB5_IconEditor_Full_Source_Code.html"><img src="../../../../../res/get.png" width="8" height="8" alt="Download Page" />VB5 IconEditor Full Source Code</a> (211K)</p><p class="nav"><a href="VB5_IconEditor_OCX.html"><img src="../../../../../res/get.png" width="8" height="8" alt="Download Page" />VB5 IconEditor OCX</a> (43K)</p><p /><p class="nav"><a href="VB6_IconEditor_Demonstration.html"><img src="../../../../../res/get.png" width="8" height="8" alt="Download Page" />VB6 IconEditor Demonstration</a> (123K)</p><p class="nav"><a href="VB6_IconEditor_Full_Source_Code.html"><img src="../../../../../res/get.png" width="8" height="8" alt="Download Page" />VB6 IconEditor Full Source Code</a> (209K)</p><p class="nav"><a href="VB6_IconEditor_OCX.html"><img src="../../../../../res/get.png" width="8" height="8" alt="Download Page" />VB6 IconEditor OCX</a> (43K)</p><br /><br /><img src="../../../../../res/information.png" width="125" height="21" alt="Information" /><p class="nav">Zip:11603</p><p class="nav">&#160;&#160;<a href="http://www.vbaccelerator.com/linkto.asp?id=11603&amp;type=Zip&amp;title=VB6%20IconEditor%20Full%20Source%20Code%2Ezip%5FvbalIconEditor">Link to code Zip</a></p><p class="nav">Applies To:</p><p class="nav">&#160;&#160;VB6</p><p class="nav">Author:</p><p class="nav">&#160;&#160;<a href="mailto:steve@vbaccelerator.com">Steve McMahon</a></p><br /><br /><img src="../../../../../res/bugTrak.png" width="125" height="21" alt="BugTrak System" /><p class="nav">No logged bugs.</p><br /><br /><img src="../../../../../res/updates.png" width="125" height="21" alt="Updates" /><p class="nav"><img src="../../../../../res/update.png" width="8" height="8" alt="Update" />21 Mar 2000<br />First Posted</p><br /><br /><img src="../../../../../res/related.png" width="125" height="21" alt="Related Items" />﻿<p class="nav"><img src="../../../../../res/rel.png" width="8" height="8" alt="Related Item" /><a href="http://www.vbaccelerator.com/article.asp?id=17">Subclassing Without The Crashes</a></p><br /><br /><img src="../../../../../res/search.png" width="125" height="21" alt="Search" />
<!-- Search Google -->
<form method="GET" action="http://www.google.com/custom">
<a href="http://www.google.com/search"><img src="../../../../../../../www.google.com/logos/Logo_40wht.gif" alt="Google" /></A><br />
<input type="text" name="q" size="31" maxlength="255" value="" class="search" /><br />
<input type="submit" name="sa" value="Search Google" class="search" />
<input type="hidden" name="cof" value="T:black;LW:330;ALC:990000;L:http://www.vbaccelerator.com/images/accl9.gif;LC:660000;LH:66;BGC:white;AH:left;VLC:999966;S:http://vbaccelerator.com/;GALT:999966;AWFID:67c7759ff27e5395;" />
<input type="hidden" name="domains" value="vbaccelerator.com" /><br />
<p class="nav"><input type="radio" name="sitesearch" value="" />Search WWW<br /></p>
<p class="nav"><input type="radio" name="sitesearch" value="vbaccelerator.com" checked="true" />vbAccelerator<br /></p>
</FORM>
<!-- Search Google -->
<br /><br />

<a href="http://www.vbaccelerator.com/home/The_Site/NewSite/article.asp"><img src="../../../../../res/newsite.png" width="125" height="129" alt="The New Site" /></a>
<br /><br />
</td><td width="100%" valign="top"><h1>vbAccelerator - Contents of code file: vbalIconEditor.ctl</h1><pre>VERSION 5.00
Begin VB.UserControl vbalIconEditor 
   ClientHeight    =   3420
   ClientLeft      =   0
   ClientTop       =   0
   ClientWidth     =   4200
   ScaleHeight     =   3420
   ScaleWidth      =   4200
   ToolboxBitmap   =   "vbalIconEditor.ctx":0000
   Begin VB.PictureBox picDisplay 
      BackColor       =   &amp;H00808000&amp;
      FillStyle       =   0  'Solid
      Height          =   3315
      Left            =   600
      ScaleHeight     =   217
      ScaleMode       =   3  'Pixel
      ScaleWidth      =   217
      TabIndex        =   1
      Top             =   60
      Width           =   3315
   End
   Begin VB.PictureBox picActual 
      AutoRedraw      =   -1  'True
      BackColor       =   &amp;H00808000&amp;
      ForeColor       =   &amp;H8000000D&amp;
      Height          =   435
      Index           =   0
      Left            =   60
      ScaleHeight     =   25
      ScaleMode       =   3  'Pixel
      ScaleWidth      =   29
      TabIndex        =   0
      Top             =   60
      Width           =   495
   End
End
Attribute VB_Name = "vbalIconEditor"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Option Explicit

Public Enum ECDDrawModeConstants
   ecModeBrush
   ecModeEraser
   ecModeFloodFill
   ecModeLine
   ecModeRectangle
   ecModeRectangleFilled
   ecModeRoundRectangle
   ecModeRoundRectangleFilled
   ecModeEllipse
   ecModeEllipseFilled
   ecModeSelection
End Enum

Public Enum ECDSelectionTypeConstants
   ecSelectionTransparent
   ecSelectionOpaque
End Enum

Private WithEvents m_cDraw As cIconEditorDraw
Attribute m_cDraw.VB_VarHelpID = -1
Private WithEvents m_cTrackMouse As cTrackMouseEvent
Attribute m_cTrackMouse.VB_VarHelpID = -1
Private m_iLastX As Long
Private m_iLastY As Long
Private m_iRXS As Long
Private m_iRYS As Long

Private m_bAutoSize As Boolean
Private m_bShowPreview As Boolean
Private m_lZoom As Long
Private m_oTransColor As OLE_COLOR
Private m_lBrushWidth As Long
Private m_lEraserWidth As Long
Private m_lRectLineWidth As Long
Private m_lLineWidth As Long
Private m_bLockAspect As Boolean

Private Type tDeviceImage
   iSizeX As Long
   iSizeY As Long
   cDepth As Long
   cPal As cPalette
End Type
Private m_tDeviceImage() As tDeviceImage
Private m_cUndo() As cUndoRedo
Private m_lUndoCount As Long
Private m_bStoreRedo As Boolean
Private m_iDeviceImageCount As Long
Private m_iCurrentImage As Long
Private m_ePointer As MousePointerConstants

Public Event MouseMove(x As Long, y As Long)
Public Event UndoChange()

Public Sub Rotate90()
   '
   Dim cDS As New cDIBSection
   If cDS.Create(DeviceImageWidth(DeviceImage), DeviceImageHeight(DeviceImage))
    Then
      ' we have a work area, load it up:
      cDS.LoadPictureBlt picActual(m_iCurrentImage).hDC
      ' Now invert it:
      cDS.Rotate90
      ' Store an Undo:
      m_cDraw.MakeUndo m_cUndo(DeviceImage), "Rotate"
      RaiseEvent UndoChange
      ' Draw the inverted image:
      cDS.PaintPicture picActual(m_iCurrentImage).hDC
      ' Render to main:
      picActual(m_iCurrentImage).Refresh
      picDisplay.Refresh
      
   Else
      gErr 3
   End If
   
End Sub
Public Sub Flip()
   '
   Dim cDS As New cDIBSection
   If cDS.Create(DeviceImageWidth(DeviceImage), DeviceImageHeight(DeviceImage))
    Then
      ' we have a work area, load it up:
      cDS.LoadPictureBlt picActual(m_iCurrentImage).hDC
      ' Now invert it:
      cDS.Flip
      ' Store an Undo:
      m_cDraw.MakeUndo m_cUndo(DeviceImage), "Flip"
      RaiseEvent UndoChange
      ' Draw the inverted image:
      cDS.PaintPicture picActual(m_iCurrentImage).hDC
      ' Render to main:
      picActual(m_iCurrentImage).Refresh
      picDisplay.Refresh
   Else
      gErr 3
   End If
   
End Sub
Public Sub Mirror()
   '
   Dim cDS As New cDIBSection
   If cDS.Create(DeviceImageWidth(DeviceImage), DeviceImageHeight(DeviceImage))
    Then
      ' we have a work area, load it up:
      cDS.LoadPictureBlt picActual(m_iCurrentImage).hDC
      ' Now invert it:
      cDS.Mirror
      ' Store an Undo:
      m_cDraw.MakeUndo m_cUndo(DeviceImage), "Mirror"
      RaiseEvent UndoChange
      ' Draw the inverted image:
      cDS.PaintPicture picActual(m_iCurrentImage).hDC
      ' Render to main:
      picActual(m_iCurrentImage).Refresh
      picDisplay.Refresh
   Else
      gErr 3
   End If
   
End Sub
Public Sub Invert()
   '
   Dim cDS As New cDIBSection
   If cDS.Create(DeviceImageWidth(DeviceImage), DeviceImageHeight(DeviceImage))
    Then
      ' we have a work area, load it up:
      cDS.LoadPictureBlt picActual(m_iCurrentImage).hDC
      ' Now invert it:
      cDS.Invert TransparentColor
      ' Store an Undo:
      m_cDraw.MakeUndo m_cUndo(DeviceImage), "Invert"
      RaiseEvent UndoChange
      ' Draw the inverted image:
      cDS.PaintPicture picActual(m_iCurrentImage).hDC
      ' Render to main:
      picActual(m_iCurrentImage).Refresh
   Else
      gErr 3
   End If
   
End Sub

Public Property Get DeviceImage() As Long
   DeviceImage = m_iCurrentImage + 1
   SelectAll
   RaiseEvent UndoChange
End Property
Public Property Let DeviceImage(ByVal nIndex As Long)
   If nIndex &gt; 0 And nIndex &lt;= m_iDeviceImageCount Then
      If m_iCurrentImage = -1 Then m_iCurrentImage = nIndex - 1
      m_cDraw.OriginalDC = picActual(nIndex - 1).hDC
      With m_tDeviceImage(nIndex)
         m_cDraw.Initialise m_lZoom, m_lZoom, .iSizeX, .iSizeY
      End With
      m_cDraw.ResizeOutput picDisplay, picActual(nIndex - 1)
      picActual(nIndex - 1).Visible = True
      If m_iCurrentImage &gt; -1 Then
         If m_iCurrentImage &lt; m_iDeviceImageCount Then
            If Not m_iCurrentImage + 1 = nIndex Then
               picActual(m_iCurrentImage).Visible = False
            End If
         End If
      End If
      m_iCurrentImage = nIndex - 1
      If Not picDisplay.Visible Then
         picDisplay.Visible = True
      End If
      pResize
      picDisplay.Cls
      picDisplay.Refresh
   Else
      gErr 5
   End If
End Property
Public Property Get DeviceImageCount() As Long
   DeviceImageCount = m_iDeviceImageCount
End Property
Public Property Get DeviceImageWidth(ByVal nIndex As Long) As Long
   DeviceImageWidth = m_tDeviceImage(nIndex).iSizeX
End Property
Public Property Get DeviceImageHeight(ByVal nIndex As Long) As Long
   DeviceImageHeight = m_tDeviceImage(nIndex).iSizeY
End Property
Public Property Get DeviceImageColours(ByVal nIndex As Long) As Long
   DeviceImageColours = m_tDeviceImage(nIndex).cDepth
End Property
Public Property Get DevicePalette(ByVal nIndex As Long) As cPalette
   If m_tDeviceImage(nIndex).cDepth &lt;= 256 Then
      Set DevicePalette = m_tDeviceImage(nIndex).cPal
   Else
      gErr 11
   End If
End Property
Public Function AddDeviceImage( _
      ByVal cx As Long, _
      ByVal cy As Long, _
      ByVal nColours As Long _
   ) As Long
Dim i As Long
   If cx &lt;= 0 Or cy &lt;= 0 Then
      gErr 6
      Exit Function
   End If
   If nColours &lt;&gt; 2 And nColours &lt;&gt; 16 And nColours &lt;&gt; 256 Then
      gErr 7
      Exit Function
   End If
   For i = 1 To m_iDeviceImageCount
      With m_tDeviceImage(i)
         If .iSizeX = cx And .iSizeY = cy And .cDepth = nColours Then
            gErr 4
            Exit Function
         End If
      End With
   Next i
   m_iDeviceImageCount = m_iDeviceImageCount + 1
   ReDim Preserve m_tDeviceImage(1 To m_iDeviceImageCount) As tDeviceImage
   With m_tDeviceImage(m_iDeviceImageCount)
      .iSizeX = cx
      .iSizeY = cy
      .cDepth = nColours
      Set .cPal = New cPalette
      Select Case nColours
      Case 2
         .cPal.CreateMono
      Case 16
         .cPal.Create16Colour
      Case 256
         .cPal.CreateWebSafe
      End Select
   End With
   ReDim Preserve m_cUndo(1 To m_iDeviceImageCount) As cUndoRedo
   Set m_cUndo(m_iDeviceImageCount) = New cUndoRedo
   m_cUndo(m_iDeviceImageCount).Init cx, cy, m_lUndoCount
   If m_iDeviceImageCount &gt; 1 Then
      Load picActual(m_iDeviceImageCount - 1)
      picActual(m_iDeviceImageCount - 1).Move picActual(0).Left,
       picActual(0).Top, (cx + 4) * Screen.TwipsPerPixelX, (cy + 4) *
       Screen.TwipsPerPixelY
   End If
End Function
Public Sub RemoveDeviceImage( _
      ByVal nIndex As Long _
   )
Dim i As Long
Dim nIdx As Long

   If nIndex &gt; 0 And nIndex &lt;= m_iDeviceImageCount Then
      If m_iDeviceImageCount &gt; 1 Then
         nIdx = nIndex - 1
         If nIndex = m_iDeviceImageCount Then
            m_iCurrentImage = 0
         End If
         Set m_cUndo(nIndex) = Nothing
         For i = nIdx To m_iDeviceImageCount - 2
            LSet m_tDeviceImage(i + 1) = m_tDeviceImage(i + 2)
            Set picActual(i).Picture = picActual(i + 1).Picture
            Set m_cUndo(i + 1) = m_cUndo(i + 2)
         Next i
         m_iDeviceImageCount = m_iDeviceImageCount - 1
         Unload picActual(m_iDeviceImageCount)
         ReDim Preserve m_tDeviceImage(1 To m_iDeviceImageCount) As tDeviceImage
         ReDim Preserve m_cUndo(1 To m_iDeviceImageCount) As cUndoRedo
         If m_iCurrentImage &gt; m_iDeviceImageCount - 1 Then
            m_iCurrentImage = m_iDeviceImageCount - 1
         End If
      Else
         picDisplay.Visible = False
         picActual(0).Visible = False
         m_iCurrentImage = -1
         Erase m_tDeviceImage
         m_iDeviceImageCount = 0
      End If
   Else
      gErr 5
      
   End If
   
End Sub
   
Public Sub NewIcon()
Dim i As Long
Dim bClearUndo As Boolean

   If m_iDeviceImageCount &gt; 0 Then
      bClearUndo = True
   End If

   ' Clear up items:
   For i = 1 To picActual.UBound
      Unload picActual(i)
      Set m_cUndo(i + 1) = Nothing
   Next i
   m_iDeviceImageCount = 0
   m_iCurrentImage = 0
   Erase m_tDeviceImage

   ' New device image:
   AddDeviceImage 32, 32, 16
   Clear
   Set m_cUndo(1) = New cUndoRedo
   m_cUndo(1).Init 32, 32, m_lUndoCount

   DeviceImage = 1
   
End Sub
Public Function LoadIcon(ByVal sFile As String) As Boolean
Dim i As Long
Dim cFI As New cFileIcon

   ' Clear existing icons:
   For i = 1 To picActual.UBound
      Unload picActual(i)
   Next i
   m_iDeviceImageCount = 0
   Erase m_tDeviceImage
   
   ' Load
   If cFI.LoadIcon(sFile) Then
      LoadIcon = pbLoadFromFileIcon(cFI)
   Else
      NewIcon
      gErr 10
   End If
   
End Function
Public Function LoadIconFromLibrary( _
      ByVal sFile As String, _
      Optional vItem As Variant _
   ) As Boolean
Dim i As Long
Dim cFI As New cFileIcon
Dim bContinue As Boolean

   ' Clear existing icons:
   For i = 1 To picActual.UBound
      Unload picActual(i)
   Next i
   m_iDeviceImageCount = 0
   Erase m_tDeviceImage
   
   If IsNumeric(vItem) Then
      If cFI.LoadIconFromEXE(sFile, vItem) Then
         bContinue = True
      End If
   Else
      If cFI.LoadIconFromEXE(sFile, , vItem) Then
         bContinue = True
      End If
   End If
   
   If bContinue Then
      LoadIconFromLibrary = pbLoadFromFileIcon(cFI)
   Else
      NewIcon
      gErr 10
   End If
   
End Function
Private Function pbLoadFromFileIcon(ByRef cFI As cFileIcon) As Boolean
Dim i As Long
Dim iDef As Long

   iDef = 1
   For i = 1 To cFI.ImageCount
      AddDeviceImage cFI.ImageWidth(i), cFI.ImageHeight(i),
       cFI.ImageColourCount(i)
      If cFI.ImageWidth(i) = 32 And cFI.ImageColourCount(i) = 16 Then
         iDef = i
      ElseIf iDef = 0 Then
         If cFI.ImageWidth(i) = 16 And cFI.ImageColourCount(i) = 16 Then
            iDef = i
         End If
      End If
      Set picActual(i - 1).Picture = cFI.IconPicture(picActual(i - 1).hDC, i)
      ' Make sure we sort out the palette:
      m_tDeviceImage(i).cPal.GetPaletteFromIcon cFI, i
   Next i
   DeviceImage = iDef
   pbLoadFromFileIcon = True
End Function
Public Property Get IsAnIconFile(ByVal sFile As String) As Boolean
Dim cFI As New cFileIcon
   IsAnIconFile = cFI.IsAnIconFile(sFile)
End Property
Public Sub SaveIcon(ByVal sFile As String)
Dim i As Long
Dim cFI As New cFileIcon

   If DeviceImageCount &gt; 0 Then
      For i = 1 To DeviceImageCount
         cFI.AddImage DeviceImageWidth(i), DeviceImageHeight(i),
          DeviceImageColours(i)
         m_tDeviceImage(i).cPal.SetPaletteToIcon cFI, i
         cFI.SetIconFromBitmap picActual(i - 1).hDC, i, 0, 0, True,
          TransparentColor
      Next i
      cFI.SaveIcon sFile
   Else
      gErr 11
   End If
   '
End Sub
Public Property Get LockAspect() As Boolean
   LockAspect = m_bLockAspect
End Property
Public Property Let LockAspect(ByVal bState As Boolean)
   m_bLockAspect = bState
   PropertyChanged "LockAspect"
End Property
Public Property Get Mode() As ECDDrawModeConstants
   Mode = m_cDraw.Mode
End Property
Public Property Let Mode(ByVal eMode As ECDDrawModeConstants)
   m_cDraw.Mode = eMode
   picDisplay.Cls
   picDisplay.Refresh
   PropertyChanged "Mode"
End Property
Public Property Get BrushWidth() As Long
   BrushWidth = m_lBrushWidth
End Property
Public Property Let BrushWidth(ByVal lWidth As Long)
   If lWidth &lt; 1 Or lWidth &gt; 255 Then
      gErr 8
      Exit Property
   End If
   m_lBrushWidth = lWidth
   PropertyChanged "BrushWidth"
End Property
Public Property Get EraserWidth() As Long
   EraserWidth = m_lEraserWidth
End Property
Public Property Let EraserWidth(ByVal lWidth As Long)
   If lWidth &lt; 1 Or lWidth &gt; 255 Then
      gErr 8
      Exit Property
   End If
   m_lEraserWidth = lWidth
   PropertyChanged "EraserWidth"
End Property
Public Property Get LineWidth() As Long
   LineWidth = m_lEraserWidth
End Property
Public Property Let LineWidth(ByVal lWidth As Long)
   If lWidth &lt; 1 Or lWidth &gt; 255 Then
      gErr 8
      Exit Property
   End If
   m_lLineWidth = lWidth
   PropertyChanged "LineWidth"
End Property
Public Property Get RectLineWidth() As Long
   RectLineWidth = m_lRectLineWidth
End Property
Public Property Let RectLineWidth(ByVal lWidth As Long)
   If lWidth &lt; 1 Or lWidth &gt; 255 Then
      gErr 8
      Exit Property
   End If
   m_lRectLineWidth = lWidth
   PropertyChanged "RectLineWidth"
End Property
Public Property Get LeftColor() As OLE_COLOR
   LeftColor = m_cDraw.LeftColour
End Property
Public Property Let LeftColor(ByVal oColor As OLE_COLOR)
   m_cDraw.LeftColour = oColor
   PropertyChanged "LeftColor"
End Property
Public Property Get RightColor() As OLE_COLOR
   RightColor = m_cDraw.RightColour
End Property
Public Property Let RightColor(ByVal oColor As OLE_COLOR)
   m_cDraw.RightColour = oColor
   PropertyChanged "RightColor"
End Property
Public Property Get SelectionMode() As ECDSelectionTypeConstants
   If m_cDraw.SelectionTransparent Then
      SelectionMode = ecSelectionTransparent
   Else
      SelectionMode = ecSelectionTransparent
   End If
End Property
Public Property Let SelectionMode(ByVal eMode As ECDSelectionTypeConstants)
   m_cDraw.SelectionTransparent = (eMode = ecSelectionTransparent)
   PropertyChanged "SelectionMode"
End Property

Public Property Get TransparentColor() As OLE_COLOR
   TransparentColor = m_oTransColor
End Property
Public Property Let TransparentColor(ByVal oColor As OLE_COLOR)
Dim i As Long
Dim cDS As New cDIBSection
Dim oOrigColor As OLE_COLOR

   oOrigColor = m_oTransColor
   m_oTransColor = oColor
   picDisplay.BackColor = TranslateColor(oColor)
   For i = picActual.LBound To picActual.UBound
      ' We change the pixels that are color
      ' lColor to the new color:
      If cDS.Create(DeviceImageWidth(i + 1), DeviceImageHeight(i + 1)) Then
         cDS.LoadPictureBlt picActual(i).hDC
         cDS.ChangeColor oOrigColor, m_oTransColor
         ' Set the colour:
         picActual(i).BackColor = m_oTransColor
         ' Not sure why this is needed, but it is.
         ' VB...
         picActual(i).Cls
         cDS.PaintPicture picActual(i).hDC
         picActual(i).Refresh
      Else
         gErr 3
      End If
   Next i
   m_cDraw.TransparentColor = m_oTransColor
   m_cDraw.OriginalDC = picActual(m_iCurrentImage).hDC
   picDisplay_Paint
   
   PropertyChanged "BackColor"
End Property

Public Property Get GridLines() As Boolean
   GridLines = m_cDraw.GridLines
End Property
Public Property Let GridLines(ByVal bState As Boolean)
   m_cDraw.GridLines = bState
   picDisplay.Cls
   picDisplay.Refresh
   PropertyChanged "GridLines"
End Property
Public Property Get TileGridLines() As Boolean
   TileGridLines = m_cDraw.TileGridLines
End Property
Public Property Let TileGridLines(ByVal bState As Boolean)
   m_cDraw.TileGridLines = bState
   picDisplay.Cls
   picDisplay.Refresh
   PropertyChanged "TileGridLines"
End Property

Public Property Get TileGridSizeX() As Long
   TileGridSizeX = m_cDraw.TileGridSizeX
End Property
Public Property Let TileGridSizeX(ByVal lX As Long)
   m_cDraw.TileGridSizeX = lX
   PropertyChanged "TileGridSizeX"
End Property
Public Property Get TileGridSizeY() As Long
   TileGridSizeY = m_cDraw.TileGridSizeY
End Property
Public Property Let TileGridSizeY(ByVal lY As Long)
   m_cDraw.TileGridSizeY = lY
   PropertyChanged "TileGridSizeY"
End Property

Public Sub Clear()
   If m_iCurrentImage &gt; -1 Then
      m_cDraw.MakeUndo m_cUndo(m_iCurrentImage + 1), "Clear"
      If m_cDraw.HasSelection Then
         ' Set colour to transparent in selection:
         m_cDraw.Cut 0, TransparentColor ' Cut with hWNd=0 :: No clipboard
         picActual(m_iCurrentImage).Refresh
         picDisplay.Cls
         picDisplay.Refresh
      Else
         ' Really clear the whole thing:
         Set picActual(m_iCurrentImage) = Nothing
         picActual(m_iCurrentImage).Cls
         m_cDraw.OriginalDC = picActual(m_iCurrentImage).hDC
         picDisplay_Paint
      End If
   End If
End Sub
Public Sub Cut()
   m_cDraw.MakeUndo m_cUndo(m_iCurrentImage + 1), "Cut"
   m_cDraw.Cut UserControl.hWnd, TransparentColor
   picActual(m_iCurrentImage).Refresh
   picDisplay.Cls
   picDisplay.Refresh
End Sub
Public Sub Copy()
   m_cDraw.Copy UserControl.hWnd
End Sub
Public Sub Paste()
   If CanPaste Then
      If m_iCurrentImage &gt; -1 Then
         m_cDraw.MakeUndo m_cUndo(m_iCurrentImage + 1), "Paste"
         m_cDraw.Cache
         m_cDraw.Paste UserControl.hWnd
      End If
   End If
End Sub
Public Property Get CanPaste() As Boolean
   CanPaste = m_cDraw.CanPaste(UserControl.hWnd)
End Property
Public Sub Undo(ByVal lDepth As Long)
   If m_iCurrentImage &gt; -1 Then
      m_cUndo(m_iCurrentImage + 1).Undo picActual(m_iCurrentImage).hDC, lDepth
      picActual(m_iCurrentImage).Refresh
      picDisplay.Cls
      picDisplay.Refresh
      SelectAll
      RaiseEvent UndoChange
   End If
End Sub
Public Sub Redo(ByVal lDepth As Long)
   If m_iCurrentImage &gt; -1 Then
      m_cUndo(m_iCurrentImage + 1).Redo picActual(m_iCurrentImage).hDC, lDepth
      picActual(m_iCurrentImage).Refresh
      picDisplay.Cls
      picDisplay.Refresh
      RaiseEvent UndoChange
   End If
End Sub
Public Property Get UndoDepth() As Long
   If m_iCurrentImage &gt; -1 Then
      UndoDepth = m_cUndo(m_iCurrentImage + 1).UndoDepth
   End If
End Property
Public Property Get UndoType(ByVal lDepth As Long) As String
   If m_iCurrentImage &gt; -1 Then
      UndoType = m_cUndo(m_iCurrentImage + 1).UndoName(lDepth - 1)
   End If
End Property
Public Property Get RedoDepth() As Long
   If m_iCurrentImage &gt; -1 Then
      RedoDepth = m_cUndo(m_iCurrentImage + 1).RedoDepth
   End If
End Property
Public Property Get RedoType(ByVal lDepth As Long) As String
   If m_iCurrentImage &gt; -1 Then
      RedoType = m_cUndo(m_iCurrentImage + 1).RedoName(lDepth)
   End If
End Property

Public Property Get Zoom() As Long
   Zoom = m_lZoom
End Property
Public Property Let Zoom(ByVal lZoom As Long)
   If lZoom &lt; 1 Or lZoom &gt; 32 Then
      gErr 1
   Else
      m_lZoom = lZoom
      m_cDraw.Initialise lZoom, lZoom, DeviceImageWidth(m_iCurrentImage + 1),
       DeviceImageHeight(m_iCurrentImage + 1)
      m_cDraw.TransparentColor = m_oTransColor
      m_cDraw.ResizeOutput picDisplay, picActual(m_iCurrentImage)
      pResize
      picDisplay.Cls
      picDisplay.Refresh
   End If
End Property

Public Property Get hWnd() As Long
   hWnd = UserControl.hWnd
End Property

Public Sub SelectAll()
Dim eMode As ECDDrawModeConstants
   ' similar to clicking outside the selection:
   eMode = m_cDraw.Mode
   m_cDraw.Mode = ecModeSelection
   picDisplay_MouseDown vbLeftButton, 0, -Screen.TwipsPerPixelX,
    -Screen.TwipsPerPixelY
   picDisplay_MouseUp vbLeftButton, 0, -Screen.TwipsPerPixelX,
    -Screen.TwipsPerPixelY
   m_cDraw.Mode = eMode
End Sub

Public Property Get AutoSize() As Boolean
   AutoSize = m_bAutoSize
End Property
Public Property Let AutoSize(ByVal bState As Boolean)
   m_bAutoSize = bState
   pResize
   PropertyChanged "AutoSize"
End Property
Public Property Get ShowPreview() As Boolean
   ShowPreview = m_bShowPreview
End Property
Public Property Let ShowPreview(ByVal bState As Boolean)
   m_bShowPreview = bState
   pResize
   PropertyChanged "ShowPreview"
End Property

Private Sub pResize()
Dim lL As Long
Dim i As Long
   If m_bShowPreview Then
      If m_iCurrentImage &gt; -1 Then
         For i = picActual.LBound To picActual.UBound
            picActual(i).Move 0, 0
         Next i
         lL = picActual(m_iCurrentImage).Width + 4 * Screen.TwipsPerPixelX
         picActual(m_iCurrentImage).Visible = True
      End If
   Else
      For i = picActual.LBound To picActual.UBound
         If picActual(i).Visible Then
            picActual(i).Visible = False
         End If
      Next i
   End If
   picDisplay.Move lL, 0
   If m_bAutoSize Then
      On Error Resume Next
      If Not (UserControl.Width = lL + picDisplay.Width) Then
         UserControl.Width = lL + picDisplay.Width
      End If
      If Not (UserControl.Height = picDisplay.Height) Then
         UserControl.Height = picDisplay.Height
      End If
   End If
End Sub

Private Sub pInitialise()
   Set m_cTrackMouse = New cTrackMouseEvent
   m_cTrackMouse.AttachMouseTracking picDisplay
   Set m_cDraw = New cIconEditorDraw
   m_cDraw.LeftColour = &amp;H80&amp;
   m_cDraw.RightColour = &amp;H800000
   m_cDraw.Mode = ecModeSelection
   m_cDraw.SelectionTransparent = True
   NewIcon
End Sub


Private Sub m_cDraw_ModifySelection(ByVal bFirstTime As Boolean)
Dim hBr As Long
Dim tR As RECT
   If bFirstTime Then
      m_cDraw.MakeUndo m_cUndo(m_iCurrentImage + 1), "Modify Selection"
      m_cDraw.GetSelection tR
      hBr = CreateSolidBrush(TranslateColor(TransparentColor))
      tR.Right = tR.Right + 1
      tR.Bottom = tR.Bottom + 1
      FillRect picActual(m_iCurrentImage).hDC, tR, hBr
      DeleteObject hBr
   End If
   picActual(m_iCurrentImage).Refresh
End Sub

Private Sub m_cDraw_SetPointer(ByVal ePointer As MousePointerConstants)
   If Not m_ePointer = ePointer Then
      picDisplay.MousePointer = ePointer
      m_ePointer = ePointer
   End If
End Sub

Private Sub m_cTrackMouse_MouseHover(Button As MouseButtonConstants, Shift As
 ShiftConstants, x As Single, y As Single)
   m_cTrackMouse.StartMouseTracking
End Sub

Private Sub m_cTrackMouse_MouseLeave()
   picDisplay_MouseMove 0, 0, -100, -100
End Sub


Private Sub picDisplay_MouseDown(Button As Integer, Shift As Integer, x As
 Single, y As Single)
Dim lForeColour As Long
Dim lBackColour As Long
Dim xs As Long, ys As Long, xe As Long, ye As Long
Static bLastNotInSelection As Boolean

   m_bStoreRedo = True
   m_cDraw.MousePos Button, Shift, x, y

   If (Button And vbLeftButton) = vbLeftButton Then
      lForeColour = m_cDraw.LeftColour
      lBackColour = m_cDraw.RightColour
   ElseIf (Button And vbRightButton) = vbRightButton Then
      lForeColour = m_cDraw.RightColour
      lBackColour = m_cDraw.LeftColour
   Else
      picDisplay_Paint
      Exit Sub
   End If
      
   m_cDraw.Transform x, y
   
   Select Case m_cDraw.Mode
   Case ecModeSelection
      m_cDraw.SelectionMouseDown x, y
      m_iRXS = x: m_iRYS = y
      
   Case ecModeRectangle, ecModeRectangleFilled, ecModeRoundRectangle,
    ecModeRoundRectangleFilled, ecModeEllipse, ecModeEllipseFilled
      picActual(m_iCurrentImage).DrawMode = vbCopyPen
      picActual(m_iCurrentImage).DrawWidth = m_lRectLineWidth
      m_cDraw.Cache
      m_iRXS = x: m_iRYS = y
      bLastNotInSelection = True
      
   Case ecModeLine
      picActual(m_iCurrentImage).DrawMode = vbCopyPen
      picActual(m_iCurrentImage).DrawWidth = m_lLineWidth
      m_cDraw.Cache
      m_iRXS = x: m_iRYS = y
      bLastNotInSelection = True
      
   Case ecModeBrush
      If m_bStoreRedo Then
         m_cDraw.MakeUndo m_cUndo(m_iCurrentImage + 1), "Brush"
         RaiseEvent UndoChange
         m_bStoreRedo = False
      End If
      picActual(m_iCurrentImage).DrawMode = vbCopyPen
      picActual(m_iCurrentImage).DrawWidth = m_lBrushWidth
      picActual(m_iCurrentImage).PSet (x, y), lForeColour
      m_iLastX = x: m_iLastY = y
      bLastNotInSelection = True
      
   Case ecModeEraser
      If m_bStoreRedo Then
         m_cDraw.MakeUndo m_cUndo(m_iCurrentImage + 1), "Eraser"
         RaiseEvent UndoChange
         m_bStoreRedo = False
      End If
      picActual(m_iCurrentImage).DrawMode = vbCopyPen
      picActual(m_iCurrentImage).DrawWidth = m_lEraserWidth
      picActual(m_iCurrentImage).PSet (x, y),
       picActual(m_iCurrentImage).BackColor
      m_iLastX = x: m_iLastY = y
      bLastNotInSelection = True
      
   Case ecModeFloodFill
      m_cDraw.MakeUndo m_cUndo(m_iCurrentImage + 1), "Fill"
      RaiseEvent UndoChange
      m_cDraw.FillArea picActual(m_iCurrentImage).hDC, x, y, lForeColour
      bLastNotInSelection = True
      
   Case Else
      Exit Sub
   End Select
   
   picActual(m_iCurrentImage).Refresh
   picDisplay_Paint
   
End Sub

Private Sub picDisplay_MouseMove(Button As Integer, Shift As Integer, x As
 Single, y As Single)
Dim lForeColour As Long
Dim lBackColour As Long
Dim hBr As Long, hBrOld As Long
Dim lAbs As Long
   
   m_cDraw.MousePos Button, Shift, x, y
   
   If (Button And vbLeftButton) = vbLeftButton Then
      lForeColour = m_cDraw.LeftColour
      lBackColour = m_cDraw.RightColour
   ElseIf (Button And vbRightButton) = vbRightButton Then
      lForeColour = m_cDraw.RightColour
      lBackColour = m_cDraw.LeftColour
   Else
      ' Button not pressed;
      If x &gt; 0 And y &gt; 0 Then
         If Not m_cTrackMouse.Tracking Then
            m_cTrackMouse.StartMouseTracking
         End If
      End If
      picDisplay_Paint
      Exit Sub
   End If
   
   m_cDraw.Transform x, y
   Select Case m_cDraw.Mode
   Case ecModeBrush
      picActual(m_iCurrentImage).DrawMode = vbCopyPen
      picActual(m_iCurrentImage).Line (m_iLastX, m_iLastY)-(x, y), lForeColour
      picActual(m_iCurrentImage).PSet (x, y), lForeColour
      
   Case ecModeEraser
      picActual(m_iCurrentImage).DrawMode = vbCopyPen
      picActual(m_iCurrentImage).Line (m_iLastX, m_iLastY)-(x, y),
       picActual(m_iCurrentImage).BackColor
      picActual(m_iCurrentImage).PSet (x, y),
       picActual(m_iCurrentImage).BackColor
   
   Case ecModeLine
      m_cDraw.UnCache
      If m_bStoreRedo Then
         m_cDraw.MakeUndo m_cUndo(m_iCurrentImage + 1), "Line"
         RaiseEvent UndoChange
         m_bStoreRedo = False
      End If
      picActual(m_iCurrentImage).DrawMode = vbCopyPen
      If m_bLockAspect Then
         lAbs = x - m_iRXS
         y = m_iRYS + lAbs
      End If
      picActual(m_iCurrentImage).Line (m_iRXS, m_iRYS)-(x, y), lForeColour
   
   Case ecModeRectangle, ecModeRectangleFilled
      m_cDraw.UnCache
      If m_bStoreRedo Then
         If m_cDraw.Mode = ecModeRectangle Then
            m_cDraw.MakeUndo m_cUndo(m_iCurrentImage + 1), "Rectangle"
         Else
            m_cDraw.MakeUndo m_cUndo(m_iCurrentImage + 1), "Filled Rectangle"
         End If
         RaiseEvent UndoChange
         m_bStoreRedo = False
      End If
      picActual(m_iCurrentImage).DrawMode = vbCopyPen
      If m_bLockAspect Then
         lAbs = x - m_iRXS
         y = m_iRYS + lAbs
      End If
      If m_cDraw.Mode = ecModeRectangleFilled Then
         picActual(m_iCurrentImage).Line (m_iRXS, m_iRYS)-(x, y), lBackColour,
          BF
      End If
      picActual(m_iCurrentImage).Line (m_iRXS, m_iRYS)-(x, y), lForeColour, B
      
   Case ecModeRoundRectangle, ecModeRoundRectangleFilled
      m_cDraw.UnCache
      If m_bStoreRedo Then
         If m_cDraw.Mode = ecModeRoundRectangle Then
            m_cDraw.MakeUndo m_cUndo(m_iCurrentImage + 1), "Rounded Rectangle"
         Else
            m_cDraw.MakeUndo m_cUndo(m_iCurrentImage + 1), "Filled Rounded
             Rectangle"
         End If
         RaiseEvent UndoChange
         m_bStoreRedo = False
      End If
      picActual(m_iCurrentImage).DrawMode = vbCopyPen
      picActual(m_iCurrentImage).ForeColor = lForeColour
      If m_cDraw.Mode = ecModeRoundRectangleFilled Then
         hBr = CreateSolidBrush(lBackColour)
         hBrOld = SelectObject(picActual(m_iCurrentImage).hDC, hBr)
      End If
      If m_bLockAspect Then
         lAbs = x - m_iRXS
         y = m_iRYS + lAbs
      End If
      RoundRect picActual(m_iCurrentImage).hDC, m_iRXS, m_iRYS, x, y, 16, 16
      If Not (hBr = 0) Then
         SelectObject picActual(m_iCurrentImage).hDC, hBrOld
         DeleteObject hBr
      End If
      
   Case ecModeEllipse, ecModeEllipseFilled
      m_cDraw.UnCache
      If m_bStoreRedo Then
         If m_cDraw.Mode = ecModeEllipse Then
            m_cDraw.MakeUndo m_cUndo(m_iCurrentImage + 1), "Ellipse"
         Else
            m_cDraw.MakeUndo m_cUndo(m_iCurrentImage + 1), "Filled Ellipse"
         End If
         RaiseEvent UndoChange
         m_bStoreRedo = False
      End If
      picActual(m_iCurrentImage).DrawMode = vbCopyPen
      picActual(m_iCurrentImage).ForeColor = lForeColour
      If m_cDraw.Mode = ecModeEllipseFilled Then
         hBr = CreateSolidBrush(lBackColour)
         hBrOld = SelectObject(picActual(m_iCurrentImage).hDC, hBr)
      End If
      If m_bLockAspect Then
         lAbs = x - m_iRXS
         y = m_iRYS + lAbs
      End If
      Ellipse picActual(m_iCurrentImage).hDC, m_iRXS, m_iRYS, x, y
      If Not (hBr = 0) Then
         SelectObject picActual(m_iCurrentImage).hDC, hBrOld
         DeleteObject hBr
      End If
      
   Case ecModeSelection
      m_cDraw.UnCache
   
      
   Case Else
      Exit Sub
   End Select
   
   m_iLastX = x
   m_iLastY = y
   
   picActual(m_iCurrentImage).Refresh
   picDisplay_Paint

End Sub

Private Sub picDisplay_MouseUp(Button As Integer, Shift As Integer, x As
 Single, y As Single)
Dim lX As Long, lY As Long
   m_cDraw.Transform x, y
   Select Case m_cDraw.Mode
   Case ecModeSelection
   End Select
   m_cDraw.MouseUp
End Sub

Private Sub picDisplay_Paint()
   If Not m_cDraw Is Nothing Then
      m_cDraw.Draw picDisplay.hDC, True
   End If
End Sub

Private Sub UserControl_Initialize()
   '
   m_lZoom = 6
   m_oTransColor = &amp;H808000
   m_bAutoSize = True
   m_bShowPreview = True
   m_iCurrentImage = -1
   m_lBrushWidth = 1
   m_lEraserWidth = 1
   m_lRectLineWidth = 1
   m_lLineWidth = 1
   m_lUndoCount = 32
   m_bShowPreview = True
   
End Sub

Private Sub UserControl_InitProperties()
   '
   pInitialise

End Sub

Private Sub UserControl_ReadProperties(PropBag As PropertyBag)
   '
   pInitialise
   
   EraserWidth = PropBag.ReadProperty("EraserWidth", 1)
   GridLines = PropBag.ReadProperty("GridLines", True)
   LeftColor = PropBag.ReadProperty("LeftColor", &amp;HFFFFFF)
   RightColor = PropBag.ReadProperty("RightColor", &amp;H0&amp;)
   LineWidth = PropBag.ReadProperty("LineWidth", 1)
   LockAspect = PropBag.ReadProperty("LockAspect", False)
   Mode = PropBag.ReadProperty("Mode", ecModeSelection)
   RectLineWidth = PropBag.ReadProperty("RectLineWidth", 1)
   SelectionMode = PropBag.ReadProperty("SelectionMode", ecSelectionTransparent)
   ShowPreview = PropBag.ReadProperty("ShowPreview", True)
   TileGridLines = PropBag.ReadProperty("TileLines", True)
   TileGridSizeX = PropBag.ReadProperty("TileGridSizeX", 16)
   TileGridSizeY = PropBag.ReadProperty("TileGridSizeY", 16)
   TransparentColor = PropBag.ReadProperty("TransparentColor", &amp;H808040)
   Zoom = PropBag.ReadProperty("Zoom", 6)
   
End Sub

Private Sub UserControl_Resize()
   '
   pResize
End Sub

Private Sub UserControl_Terminate()
   '
End Sub

Private Sub UserControl_WriteProperties(PropBag As PropertyBag)
   '
   PropBag.WriteProperty "EraserWidth", EraserWidth, 1
   PropBag.WriteProperty "GridLines", GridLines, True
   PropBag.WriteProperty "LeftColor", LeftColor, &amp;HFFFFFF
   PropBag.WriteProperty "RightColor", RightColor, &amp;H0&amp;
   PropBag.WriteProperty "LineWidth", LineWidth, 1
   PropBag.WriteProperty "LockAspect", LockAspect, False
   PropBag.WriteProperty "Mode", Mode, ecModeSelection
   PropBag.WriteProperty "RectLineWidth", RectLineWidth, 1
   PropBag.WriteProperty "SelectionMode", SelectionMode, ecSelectionTransparent
   PropBag.WriteProperty "ShowPreview", ShowPreview, True
   PropBag.WriteProperty "TileLines", TileGridLines, True
   PropBag.WriteProperty "TileGridSizeX", TileGridSizeX, 16
   PropBag.WriteProperty "TileGridSizeY", TileGridSizeY, 16
   PropBag.WriteProperty "TransparentColor", TransparentColor, &amp;H808040
   PropBag.WriteProperty "Zoom", Zoom, 6
   
End Sub


</pre><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p></td><td class="rightbar" valign="top" bgcolor="#C2BEB1">
<!-- No right bar content currently defined -->
</td></tr><tr class="footer"><td></td>
<td>
<p class="center"></p>
</td>
<td></td>
</tr><tr><td colspan="3"><hr /></td></tr><tr class="footer"><td valign="top"><a href="http://www.vbaccelerator.com/home/index.asp"><img width="125" height="25" src="../../../../../res/vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="http://www.vbaccelerator.com/home/index.asp">Home</a>&#160;.&#160;<a href="../../../../index.html">VB</a>&#160;.&#160;<a href="../../../index.html">Code</a>&#160;.&#160;<a href="../../index.html">Controls</a>&#160;.&#160;<a href="../index.html">Icon Controls</a>&#160;.&#160;<a href="article.html">vbAccelerator Icon Editor Control</a>&#160;.&#160;<a href="VB6_IconEditor_Full_Source_Code.html">VB6 IconEditor Full Source Code</a>&#160;.&#160;vbalIconEditor.ctl</p><br /><p class="nav"><a href="http://www.vbaccelerator.com/home/The_Site/Copyright/article.asp">Copyright</a> &#169; 2003 Steve McMahon <a href="mailto:steve@vbaccelerator.com">steve@vbaccelerator.com</a>.  All rights reserved.<br />Last Updated: 12 April 2003</p></td><td></td></tr></table>
</body>
<!-- Mirrored from www.vbaccelerator.com/home/VB/Code/Controls/Icon_Controls/Icon_Editor/VB6_IconEditor_Full_Source_Code_zip_vbalIconEditor_ctl.asp by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 Jun 2015 21:30:54 GMT -->
</html>