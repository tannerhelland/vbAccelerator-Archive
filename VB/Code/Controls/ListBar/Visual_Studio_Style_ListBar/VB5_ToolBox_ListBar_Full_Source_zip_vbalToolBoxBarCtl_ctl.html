<html lang="en" >

<!-- Mirrored from www.vbaccelerator.com/home/VB/Code/Controls/ListBar/Visual_Studio_Style_ListBar/VB5_ToolBox_ListBar_Full_Source_zip_vbalToolBoxBarCtl_ctl.asp by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 Jun 2015 21:30:52 GMT -->
<head>
<title>vbAccelerator - Contents of code file: vbalToolBoxBarCtl.ctl</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta name="AUTHOR" content="Steve McMahon" /><meta name="KEYWORDS" content=".NET, .NET Framework, C#, CSharp, VB, Visual Basic, VB5, VB6, Visual Basic, Active X, Controls, Components" /><meta name="DESCRIPTION" content="vbAccelerator - Contents of code file: vbalToolBoxBarCtl.ctl" /><link rel="stylesheet" href="../../../../../res/screen.css" media="SCREEN" /><link rel="stylesheet" href="../../../../../res/print.css" media="PRINT" /></head><body>
<table>
<tr class="adbar" bgcolor="#83726a"><tr class="footer"><td></td>
<td>
<p class="center">

<script type="text/javascript"><!--
google_ad_client = "pub-4690375644913255";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_channel ="";
google_ad_type = "text_image";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_url = "008000.html";
google_color_text = "000000";
//--></script>
<script type="text/javascript"
  src="../../../../../../../pagead2.googlesyndication.com/pagead/f.txt">
</script>
</p>
</td>
<td></td>
</tr></tr><tr class="navbar"><td><a href="http://www.vbaccelerator.com/home/index.asp"><img width="125" height="25" src="../../../../../res/vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="http://www.vbaccelerator.com/home/index.asp">Home</a>&#160;.&#160;<a href="../../../../index.html">VB</a>&#160;.&#160;<a href="../../../index.html">Code</a>&#160;.&#160;<a href="../../index.html">Controls</a>&#160;.&#160;<a href="../index.html">ListBar</a>&#160;.&#160;<a href="article.html">vbAccelerator Visual Studio Style ToolBox ListBar</a>&#160;.&#160;<a href="VB5_ToolBox_ListBar_Full_Source.html">VB5 ToolBox ListBar Full Source</a>&#160;.&#160;vbalToolBoxBarCtl.ctl</p></td><td></td></tr><tr class="navbar"><td colspan="3"><hr /></td></tr><tr valign="top"><td class="sidebar"><img src="../../../../../res/download.png" width="125" height="21" alt="Downloads" /><p class="nav"><a href="VB5_ToolBox_ListBar_Control_Binary.html"><img src="../../../../../res/get.png" width="8" height="8" alt="Download Page" />VB5 ToolBox ListBar Control Binary</a> (30K)</p><p class="nav"><a href="VB5_ToolBox_ListBar_Demonstration.html"><img src="../../../../../res/get.png" width="8" height="8" alt="Download Page" />VB5 ToolBox ListBar Demonstration</a> (18K)</p><p class="nav"><a href="VB5_ToolBox_ListBar_Full_Source.html"><img src="../../../../../res/get.png" width="8" height="8" alt="Download Page" />VB5 ToolBox ListBar Full Source</a> (75K)</p><p /><p class="nav"><a href="VB6_ToolBox_ListBar_Control_Binary.html"><img src="../../../../../res/get.png" width="8" height="8" alt="Download Page" />VB6 ToolBox ListBar Control Binary</a> (30K)</p><p class="nav"><a href="VB6_ToolBox_ListBar_Demonstration.html"><img src="../../../../../res/get.png" width="8" height="8" alt="Download Page" />VB6 ToolBox ListBar Demonstration</a> (17K)</p><p class="nav"><a href="VB6_ToolBox_ListBar_Full_Source.html"><img src="../../../../../res/get.png" width="8" height="8" alt="Download Page" />VB6 ToolBox ListBar Full Source</a> (74K)</p><br /><br /><img src="../../../../../res/information.png" width="125" height="21" alt="Information" /><p class="nav">Zip:3838</p><p class="nav">&#160;&#160;<a href="http://www.vbaccelerator.com/linkto.asp?id=3838&amp;type=Zip&amp;title=VB5%20ToolBox%20ListBar%20Full%20Source%2Ezip%5FvbalToolBoxBarCtl">Link to code Zip</a></p><p class="nav">Applies To:</p><p class="nav">&#160;&#160;VB5</p><p class="nav">Author:</p><p class="nav">&#160;&#160;<a href="mailto:steve@vbaccelerator.com">Steve McMahon</a></p><br /><br /><img src="../../../../../res/bugTrak.png" width="125" height="21" alt="BugTrak System" />﻿<p class="nav"><a href="bugTrak.html">BugTrak</a></p><p class="nav"><a href="bugTrak.html#bugs"><img src="../../../../../res/btBug.png" width="16" height="16" alt="Bug" />&#160;Bugs:</a> 3 / 3</p><p class="nav"><a href="bugTrak.html#issues"><img src="../../../../../res/btIssue.png" width="16" height="16" alt="Issue" />&#160;Issues:</a> 0 / 0</p><p class="nav"><a href="bugTrak.html#questions"><img src="../../../../../res/btQuestion.png" width="16" height="16" alt="Question" />&#160;Questions:</a> 0 / 0</a></p><p class="nav">Updated:27 October 2003</p>
<br /><br /><img src="../../../../../res/updates.png" width="125" height="21" alt="Updates" /><p class="nav"><img src="../../../../../res/update.png" width="8" height="8" alt="Update" />12 Feb 2003<br />First Posted</p><br /><br /><img src="../../../../../res/related.png" width="125" height="21" alt="Related Items" />﻿<p class="nav"><img src="../../../../../res/rel.png" width="8" height="8" alt="Related Item" /><a href="http://www.vbaccelerator.com/article.asp?id=3772">Clipboard Ring Sample</a></p><p class="nav"><img src="../../../../../res/rel.png" width="8" height="8" alt="Related Item" /><a href="http://www.vbaccelerator.com/article.asp?id=2767">vbAccelerator Visual Studio Style Tab Control</a></p><br /><br /><img src="../../../../../res/search.png" width="125" height="21" alt="Search" />
<!-- Search Google -->
<form method="GET" action="http://www.google.com/custom">
<a href="http://www.google.com/search"><img src="../../../../../../../www.google.com/logos/Logo_40wht.gif" alt="Google" /></A><br />
<input type="text" name="q" size="31" maxlength="255" value="" class="search" /><br />
<input type="submit" name="sa" value="Search Google" class="search" />
<input type="hidden" name="cof" value="T:black;LW:330;ALC:990000;L:http://www.vbaccelerator.com/images/accl9.gif;LC:660000;LH:66;BGC:white;AH:left;VLC:999966;S:http://vbaccelerator.com/;GALT:999966;AWFID:67c7759ff27e5395;" />
<input type="hidden" name="domains" value="vbaccelerator.com" /><br />
<p class="nav"><input type="radio" name="sitesearch" value="" />Search WWW<br /></p>
<p class="nav"><input type="radio" name="sitesearch" value="vbaccelerator.com" checked="true" />vbAccelerator<br /></p>
</FORM>
<!-- Search Google -->
<br /><br />

<a href="http://www.vbaccelerator.com/home/The_Site/NewSite/article.asp"><img src="../../../../../res/newsite.png" width="125" height="129" alt="The New Site" /></a>
<br /><br />
</td><td width="100%" valign="top"><h1>vbAccelerator - Contents of code file: vbalToolBoxBarCtl.ctl</h1><pre>VERSION 5.00
Begin VB.UserControl vbalToolBoxBarCtl 
   Alignable       =   -1  'True
   ClientHeight    =   3600
   ClientLeft      =   0
   ClientTop       =   0
   ClientWidth     =   4800
   ControlContainer=   -1  'True
   OLEDropMode     =   1  'Manual
   ScaleHeight     =   3600
   ScaleWidth      =   4800
   ToolboxBitmap   =   "vbalToolBoxBarCtl.ctx":0000
   Begin VB.Timer m_tmr 
      Enabled         =   0   'False
      Interval        =   25
      Left            =   1740
      Top             =   1200
   End
End
Attribute VB_Name = "vbalToolBoxBarCtl"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Option Explicit

'
 ===============================================================================
=======
' Name:     vbalToolBoxBarCtl.ctl
' Author:   Steve McMahon (steve@vbaccelerator.com)
' Date:     9 February 2003
'
' Requires: -
'
' Copyright  2003 Steve McMahon for vbAccelerator
'
 -------------------------------------------------------------------------------
-------
' Visit vbAccelerator - advanced free source code for VB programmers
'    http://vbaccelerator.com
'
 -------------------------------------------------------------------------------
-------
'
' Implementation of the vbalToolBarBox control.
'
' FREE SOURCE CODE - ENJOY!
' Do not sell this code.  Credit vbAccelerator.
'
 ===============================================================================
=======

Private Type POINTAPI
   x As Long
   y As Long
End Type

Private Type RECT
   Left As Long
   Top As Long
   right As Long
   bottom As Long
End Type

Private Declare Function GetVersion Lib "kernel32" () As Long
Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (pDest As
 Any, pSrc As Any, ByVal ByteLen As Long)
Private Declare Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long
Private Declare Function ScreenToClient Lib "user32" (ByVal hWnd As Long,
 lpPoint As POINTAPI) As Long
Private Declare Function PtInRect Lib "user32" (lpRect As RECT, ByVal x As
 Long, ByVal y As Long) As Long
Private Declare Function FillRect Lib "user32" (ByVal hdc As Long, lpRect As
 RECT, ByVal hBrush As Long) As Long
Private Declare Function OffsetRect Lib "user32" (lpRect As RECT, ByVal x As
 Long, ByVal y As Long) As Long
Private Declare Function GetClientRect Lib "user32" (ByVal hWnd As Long, lpRect
 As RECT) As Long
Private Declare Function SelectObject Lib "gdi32" (ByVal hdc As Long, ByVal
 hObject As Long) As Long
Private Declare Function CreateSolidBrush Lib "gdi32" (ByVal crColor As Long)
 As Long
Private Declare Function GetSysColorBrush Lib "user32" (ByVal nIndex As Long)
 As Long
Private Declare Function SetTextColor Lib "gdi32" (ByVal hdc As Long, ByVal
 crColor As Long) As Long
Private Declare Function SetBkColor Lib "gdi32" (ByVal hdc As Long, ByVal
 crColor As Long) As Long
Private Declare Function DrawText Lib "user32" Alias "DrawTextA" (ByVal hdc As
 Long, ByVal lpStr As String, ByVal nCount As Long, lpRect As RECT, ByVal
 wFormat As Long) As Long
Private Declare Function DrawTextW Lib "user32" (ByVal hdc As Long, ByVal lpStr
 As Long, ByVal nCount As Long, lpRect As RECT, ByVal wFormat As Long) As Long
Private Declare Function BitBlt Lib "gdi32" (ByVal hDestDC As Long, ByVal x As
 Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal
 hSrcDC As Long, ByVal xSrc As Long, ByVal ySrc As Long, ByVal dwRop As Long)
 As Long
Private Declare Function GetSysColor Lib "user32" (ByVal nIndex As Long) As Long
Private Declare Function LineTo Lib "gdi32" (ByVal hdc As Long, ByVal x As
 Long, ByVal y As Long) As Long
Private Declare Function MoveToEx Lib "gdi32" (ByVal hdc As Long, ByVal x As
 Long, ByVal y As Long, lpPoint As POINTAPI) As Long
Private Declare Function CreatePen Lib "gdi32" (ByVal nPenStyle As Long, ByVal
 nWidth As Long, ByVal crColor As Long) As Long
Private Const PS_SOLID = 0
Private Declare Function SetBkMode Lib "gdi32" (ByVal hdc As Long, ByVal
 nBkMode As Long) As Long
Private Const OPAQUE = 2
Private Const TRANSPARENT = 1
Private Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As
 Long
Private Declare Function OleTranslateColor Lib "OLEPRO32.DLL" (ByVal OLE_COLOR
 As Long, ByVal HPALETTE As Long, pccolorref As Long) As Long
Private Const CLR_INVALID = -1

' DrawText
Private Enum EDrawTextFormat
   DT_BOTTOM = &amp;H8
   DT_CALCRECT = &amp;H400
   DT_CENTER = &amp;H1
   DT_EXPANDTABS = &amp;H40
   DT_EXTERNALLEADING = &amp;H200
   DT_INTERNAL = &amp;H1000
   DT_LEFT = &amp;H0
   DT_NOCLIP = &amp;H100
   DT_NOPREFIX = &amp;H800
   DT_RIGHT = &amp;H2
   DT_SINGLELINE = &amp;H20
   DT_TABSTOP = &amp;H80
   DT_TOP = &amp;H0
   DT_VCENTER = &amp;H4
   DT_WORDBREAK = &amp;H10
   DT_EDITCONTROL = &amp;H2000&amp;
   DT_PATH_ELLIPSIS = &amp;H4000&amp;
   DT_END_ELLIPSIS = &amp;H8000&amp;
   DT_MODIFYSTRING = &amp;H10000
   DT_RTLREADING = &amp;H20000
   DT_WORD_ELLIPSIS = &amp;H40000
End Enum

' Image list functions:
Private Declare Function ImageList_Draw Lib "COMCTL32.DLL" ( _
        ByVal hIml As Long, _
        ByVal i As Long, _
        ByVal hdcDst As Long, _
        ByVal x As Long, _
        ByVal y As Long, _
        ByVal fStyle As Long _
    ) As Long
Private Declare Function ImageList_GetIcon Lib "COMCTL32.DLL" ( _
        ByVal hIml As Long, _
        ByVal i As Long, _
        ByVal diIgnore As Long _
    ) As Long
Private Declare Function ImageList_GetImageCount Lib "COMCTL32.DLL" ( _
        ByVal hIml As Long _
    ) As Long
Private Declare Function ImageList_GetImageRect Lib "COMCTL32.DLL" ( _
        ByVal hIml As Long, _
        ByVal i As Long, _
        prcImage As RECT _
    ) As Long
Private Declare Function ImageList_GetIconSize Lib "COMCTL32.DLL" ( _
        ByVal hIml As Long, _
        ByVal cx As Long, _
        ByVal cy As Long _
    ) As Long
Private Const ILD_NORMAL = 0
Private Const ILD_TRANSPARENT = 1
Private Const ILD_BLEND25 = 2
Private Const ILD_SELECTED = 4
Private Const ILD_FOCUS = 4
Private Const ILD_MASK = &amp;H10&amp;
Private Const ILD_IMAGE = &amp;H20&amp;
Private Const ILD_ROP = &amp;H40&amp;
Private Const ILD_OVERLAYMASK = 3840

Private Declare Function DrawState Lib "user32" Alias "DrawStateA" _
   (ByVal hdc As Long, _
   ByVal hBrush As Long, _
   ByVal lpDrawStateProc As Long, _
   ByVal lparam As Long, _
   ByVal wParam As Long, _
   ByVal x As Long, _
   ByVal y As Long, _
   ByVal cx As Long, _
   ByVal cy As Long, _
   ByVal fuFlags As Long) As Long
'/* Image type */
Private Const DST_COMPLEX = &amp;H0
Private Const DST_TEXT = &amp;H1
Private Const DST_PREFIXTEXT = &amp;H2
Private Const DST_ICON = &amp;H3
Private Const DST_BITMAP = &amp;H4
' /* State type */
Private Const DSS_NORMAL = &amp;H0
Private Const DSS_UNION = &amp;H10         ' /* Gray string appearance */
Private Const DSS_DISABLED = &amp;H20
Private Const DSS_MONO = &amp;H80
Private Const DSS_RIGHT = &amp;H8000

Private Declare Function DestroyIcon Lib "user32" (ByVal hIcon As Long) As Long

Private Declare Function timeGetTime Lib "winmm.dll" () As Long

Private Type tBarItem
   
   sCaption As String
   sToolTipText As String
   sKey As String
   lItemData As Long
   lIconIndex As Long
   sTag As String
   bEnabled As Boolean
   bSelected As Boolean
   bCanDrag As Boolean
   
   tR As RECT
   
   bDown As Boolean
   bTrack As Boolean
   
   lId As Long
End Type

Private Type tBar
   
   sCaption As String
   sToolTipText As String
   sKey As String
   lItemData As Long
   lIconIndex As Long
   sTag As String
   bListView As Boolean
   bSorted As Boolean
   bVisible As Boolean
   
   lObjPtrPanel As Long
   lItemCount As Long
   tItem() As tBarItem
   lSelItem As Long
   
   tCaptionR As RECT
   tScrollUpR As RECT
   bTrackScrollUp As Boolean
   bDownScrollUp As Boolean
   tScrollDownR As RECT
   bTrackScrollDown As Boolean
   bDownScrollDown As Boolean
   tClientR As RECT
   bDown As Boolean
   bTrack As Boolean
   
   lSize As Long
   lOffset As Long
   
   lId As Long
   
End Type


Private m_hWnd As Long
Private m_iBarCount As Long
Private m_tBar() As tBar
Private m_bIsNT As Boolean
Private m_lBarIdGenerator As Long
Private m_lItemIdGenerator As Long
Private m_lCaptionHeight As Long
Private m_lClickTime As Long
Private m_lItemHeight As Long
Private m_bRunTime As Boolean

Private m_iSelBar As Long
Private m_oBackColor As OLE_COLOR
Private m_oForeColor As OLE_COLOR
Private m_fnt As IFont

Private m_iDragBar As Long
Private m_bClickBar As Boolean
Private m_bClickScroll As Boolean
Private m_iDragItem As Long
Private m_iDragOverItem As Long
Private m_tDownP As POINTAPI

Private m_hIml As Long
Private m_ptrVb6ImageList As Long
Private m_lIconWidth As Long
Private m_lIconHeight As Long

Public Enum EToolboxBarCtlDragDataTypes
   tbbCfItemIdentifier = &amp;HFFFFBF02
   tbbCfItemTag = &amp;HFFFFBF03
End Enum

Public Enum EToolboxBarCtlBorderStyleConstants
   tbbBorderStyleNone = 0
   tbbBorderStyleSingle = 1
End Enum

Private m_cMemDC As pcMemDC

Public Event BarClick(Bar As cToolBoxBar, ByVal Button As MouseButtonConstants,
 ByVal Shift As ShiftConstants, ByVal x As Single, ByVal y As Single)
Public Event BarDblClick(Bar As cToolBoxBar, ByVal Button As
 MouseButtonConstants, ByVal Shift As ShiftConstants, ByVal x As Single, ByVal
 y As Single)
Public Event BarSelected(Bar As cToolBoxBar)
Public Event ItemClick(Item As cToolItem, ByVal Button As MouseButtonConstants,
 ByVal Shift As ShiftConstants, ByVal x As Single, ByVal y As Single)
Public Event ItemDblClick(Item As cToolItem, ByVal Button As
 MouseButtonConstants, ByVal Shift As ShiftConstants, ByVal x As Single, ByVal
 y As Single)
Public Event ItemSelected(Item As cToolItem)
Public Event KeyDown(Key As Integer, Shift As Integer)
Public Event KeyPress(KeyAscii As Integer)
Public Event KeyUp(Key As Integer, Shift As Integer)


Public Property Get BorderStyle() As EToolboxBarCtlBorderStyleConstants
   BorderStyle = UserControl.BorderStyle
End Property
Public Property Let BorderStyle(ByVal style As
 EToolboxBarCtlBorderStyleConstants)
   UserControl.BorderStyle = style
   pResize
   PropertyChanged "BorderStyle"
End Property

Public Property Get BackColor() As OLE_COLOR
Attribute BackColor.VB_Description = "Gets/sets the background colour of the
 control."
Attribute BackColor.VB_UserMemId = -501
   BackColor = m_oBackColor
End Property
Public Property Let BackColor(ByVal oColor As OLE_COLOR)
   m_oBackColor = oColor
   pDraw
   PropertyChanged "BackColor"
End Property

Public Property Get ForeColor() As OLE_COLOR
Attribute ForeColor.VB_Description = "Gets/sets the foreground colour of the
 control."
Attribute ForeColor.VB_UserMemId = -513
   ForeColor = m_oForeColor
End Property
Public Property Let ForeColor(ByVal oColor As OLE_COLOR)
   m_oForeColor = oColor
   pDraw
   PropertyChanged "ForeColor"
End Property

Public Property Get Font() As IFont
Attribute Font.VB_Description = "Gets/sets the font used to draw the control."
Attribute Font.VB_UserMemId = -512
   Set Font = m_fnt
End Property
Public Property Let Font(iFnt As IFont)
   pSetFont iFnt
End Property
Public Property Set Font(iFnt As IFont)
   pSetFont iFnt
End Property

Private Sub pSetFont(iFnt As IFont)
   Set m_fnt = iFnt
   Set UserControl.Font = iFnt
   
   Dim tR As RECT
   tR.right = 128
   tR.bottom = 128
   DrawText UserControl.hdc, "Xg", -1, tR, DT_SINGLELINE Or DT_CALCRECT
   m_lCaptionHeight = tR.bottom - tR.Top + 6
   
   pResize
   PropertyChanged "Font"
End Sub

Public Sub Move( _
      Optional fLeft As Variant, _
      Optional fTop As Variant, _
      Optional fWidth As Variant, _
      Optional fHeight As Variant _
   )
   If (IsMissing(fLeft)) Then
      fLeft = UserControl.Extender.Left
   End If
   If (IsMissing(fTop)) Then
      fTop = UserControl.Extender.Top
   End If
   If (IsMissing(fWidth)) Then
      fWidth = UserControl.Width
   End If
   If (IsMissing(fHeight)) Then
      fHeight = UserControl.Height
   End If
   UserControl.Extender.Move fLeft, fTop, fWidth, fHeight
End Sub

Public Function ScaleX( _
      ByVal fWidth As Single, _
      ByVal eScaleModeFrom As ScaleModeConstants, _
      ByVal eScaleModeTo As ScaleModeConstants _
   )
   ScaleX = UserControl.ScaleX(fWidth, eScaleModeFrom, eScaleModeTo)
End Function
Public Function ScaleY( _
      ByVal fHeight As Single, _
      ByVal eScaleModeFrom As ScaleModeConstants, _
      ByVal eScaleModeTo As ScaleModeConstants _
   )
   ScaleY = UserControl.ScaleY(fHeight, eScaleModeFrom, eScaleModeTo)
End Function
Public Property Get ScaleMode() As ScaleModeConstants
   ScaleMode = UserControl.ScaleMode
End Property
Public Property Let ScaleMode(ByVal eMode As ScaleModeConstants)
   UserControl.ScaleMode = eMode
   PropertyChanged "ScaleMode"
End Property
Public Sub Refresh()
   UserControl.Refresh
End Sub

Public Property Let ImageList( _
        ByRef vImageList As Variant _
    )
Attribute ImageList.VB_Description = "Associates an ImageList with the control.
  If using a VB Image List, provide the Image List object, otherwise provide
 the hImageList handle."
    m_hIml = 0
    m_ptrVb6ImageList = 0
    If (VarType(vImageList) = vbLong) Then
        ' Assume a handle to an image list:
        m_hIml = vImageList
    ElseIf (VarType(vImageList) = vbObject) Then
        ' Assume a VB image list:
        On Error Resume Next
        ' Get the image list initialised..
        vImageList.ListImages(1).draw 0, 0, 0, 1
        m_hIml = vImageList.hImageList
        If (Err.Number = 0) Then
            ' Check for VB6 image list:
            If (TypeName(vImageList) = "ImageList") Then
                If (vImageList.ListImages.Count &lt;&gt;
                 ImageList_GetImageCount(m_hIml)) Then
                    Dim o As Object
                    Set o = vImageList
                    m_ptrVb6ImageList = ObjPtr(o)
                End If
            End If
        Else
            Debug.Print "Failed to Get Image list Handle", "cVGrid.ImageList"
        End If
        On Error GoTo 0
    End If
    If (m_hIml &lt;&gt; 0) Then
        If (m_ptrVb6ImageList &lt;&gt; 0) Then
            m_lIconWidth = vImageList.ImageWidth
            m_lIconHeight = vImageList.ImageHeight
        Else
            Dim rc As RECT
            ImageList_GetImageRect m_hIml, 0, rc
            m_lIconWidth = rc.right - rc.Left
            m_lIconHeight = rc.bottom - rc.Top
        End If
    End If
End Property

Public Property Get Bars() As cToolBoxBarCollection
Attribute Bars.VB_Description = "Gets the bars associated with the control."
   '
   Dim cT As New cToolBoxBarCollection
   cT.Init ObjPtr(Me), m_hWnd
   Set Bars = cT
   '
End Property

Public Property Get ItemFromDragData(b() As Byte) As cToolItem
Attribute ItemFromDragData.VB_Description = "Gets an Item from the Data with
 format tbbCfItemIdentifier."
   '
   Dim s As String
   s = b
   Dim iPos As Long
   iPos = InStr(s, ":")
   If (iPos &gt; 1) Then
      On Error Resume Next
      Dim lBarId As Long
      Dim lItemId As Long
      lBarId = CLng(Left(s, iPos - 1))
      lItemId = CLng(Mid(s, iPos + 1))
      On Error GoTo 0
      If (lBarId &gt; 0) And (lItemId &gt; 0) Then
         Dim lBarIndex As Long
         lBarIndex = plBarForId(lBarId)
         If (lBarIndex &gt; 0) Then
            Dim lItemIndex As Long
            lItemIndex = plItemForId(lBarIndex, lItemId)
            If (lItemIndex &gt; 0) Then
               Dim cT As New cToolItem
               cT.fInit ObjPtr(Me), m_hWnd, lBarId, lItemId
               Set ItemFromDragData = cT
            End If
         End If
      End If
   End If
   '
End Property

' ---------------------------------------
' START Bar Collection
' ---------------------------------------
Friend Property Get fBarCount() As Long
   '
   fBarCount = m_iBarCount
   '
End Property

Friend Property Get fNextBar(ByVal lBarId As Long, ByVal iDir As Long, ByVal
 bVisibleOnly As Boolean) As cToolBoxBar
   '
   Dim lIndex As Long
   lIndex = plBarForId(lBarId)
   If (lIndex &gt; 0) Then
      
      Dim lNextIndex As Long
      Dim i As Long
      
      If (iDir = 1) Then
         If (bVisibleOnly) Then
            For i = lIndex + 1 To m_iBarCount
               If (m_tBar(i).bVisible) Then
                  lNextIndex = i
                  Exit For
               End If
            Next i
         Else
            If (lIndex &lt; m_iBarCount) Then
               lNextIndex = lIndex + 1
            End If
         End If
      Else
         If (bVisibleOnly) Then
            For i = lIndex - 1 To 1 Step -1
               If (m_tBar(i).bVisible) Then
                  lNextIndex = i
                  Exit For
               End If
            Next i
         Else
            If (lIndex &gt; 1) Then
               lNextIndex = lIndex - 1
            End If
         End If
      End If
      If (lNextIndex &gt; 0) Then
         Dim cT As New cToolBoxBar
         cT.fInit ObjPtr(Me), m_hWnd, m_tBar(lNextIndex).lId
         Set fNextBar = cT
      End If
   End If
   '
End Property

Friend Property Get fBarItem(Key As Variant) As cToolBoxBar
   '
   Dim lIndex As Long
   lIndex = plBarIndex(Key)
   If (lIndex &gt; 0) Then
      Dim cT As New cToolBoxBar
      cT.fInit ObjPtr(Me), m_hWnd, m_tBar(lIndex).lId
      Set fBarItem = cT
   End If
   '
End Property
Friend Sub fBarRemove(Key As Variant)
   '
   Dim lIndex As Long
   lIndex = plBarIndex(Key)
   If (lIndex &gt; 0) Then
      If (m_iBarCount &gt; 1) Then
         ' shift everything from lIndex+ 1 to m_iBarCount
         ' up one:
         Dim i As Long
         For i = lIndex + 1 To m_iBarCount
            LSet m_tBar(i - 1) = m_tBar(i)
         Next i
         m_iBarCount = m_iBarCount - 1
         If (m_iSelBar &gt; m_iBarCount) Then
            m_iSelBar = m_iBarCount
         End If
      Else
         ' no bars
         m_iBarCount = 0
         m_iSelBar = 0
         Erase m_tBar
      End If
      pResize
   End If
   '
End Sub
Friend Sub fBarMove( _
      ByVal lId As Long, _
      ByVal iDir As Long _
   )
Dim lIndex As Long
   lIndex = plBarForId(lId)
   If (lIndex &gt; 0) Then
      
      Dim lNewIndex As Long
      Dim cT As cToolBoxBar
      
      Set cT = fNextBar(lId, iDir, True)
      If Not cT Is Nothing Then
         lNewIndex = cT.Index
      Else
         If (iDir &gt; 0) Then
            ' Move down:
            If (lIndex &lt; m_iBarCount) Then
               lNewIndex = lIndex + 1
            End If
         Else
            ' Move up:
            If (lIndex &gt; 1) Then
               lNewIndex = lIndex - 1
            End If
         End If
      End If
      
      Dim tSwap As tBar
      LSet tSwap = m_tBar(lNewIndex)
      LSet m_tBar(lNewIndex) = m_tBar(lIndex)
      LSet m_tBar(lIndex) = tSwap
      If (lIndex = m_iSelBar) Then
         m_iSelBar = lNewIndex
      ElseIf (lNewIndex = m_iSelBar) Then
         m_iSelBar = lIndex
      End If
      pResize
      
   End If
End Sub

Friend Function fBarAdd( _
      Optional Key As Variant, _
      Optional KeyBefore As Variant, _
      Optional Caption As String, _
      Optional IconIndex As Long _
   ) As cToolBoxBar
   '
   ' check the Key:
   If (pbCheckKey(Key)) Then
      
      ' Prepare position to put the new bar:
      Dim lIndex As Long
      If Not IsMissing(KeyBefore) Then
         lIndex = plBarIndex(Key)
         If (lIndex &lt;= 0) Then
            Exit Function
         End If
         ' shift things up:
         ReDim Preserve m_tBar(1 To m_iBarCount + 1) As tBar
         Dim i As Long
         For i = m_iBarCount To lIndex Step -1
            LSet m_tBar(i + 1) = m_tBar(i)
         Next i
         m_iBarCount = m_iBarCount + 1
      Else
         ReDim Preserve m_tBar(1 To m_iBarCount + 1) As tBar
         m_iBarCount = m_iBarCount + 1
         lIndex = m_iBarCount
      End If
      
      ' add the bar:
      m_lBarIdGenerator = m_lBarIdGenerator + 1
      With m_tBar(lIndex)
         .lId = m_lBarIdGenerator
         If Not IsMissing(Caption) Then
            .sCaption = Caption
         End If
         If Not IsMissing(Key) Then
            .sKey = Key
         End If
         If Not IsMissing(IconIndex) Then
            .lIconIndex = IconIndex
         End If
         .bListView = True
         .bVisible = True
      End With
      If (m_iBarCount = 1) Then
         m_iSelBar = 1
      End If
      pResize
      
      Dim cT As New cToolBoxBar
      cT.fInit ObjPtr(Me), m_hWnd, m_tBar(lIndex).lId
      Set fBarAdd = cT
      
   End If
   '
End Function

Private Property Get plBarIndex(Key As Variant) As Long
On Error GoTo errorHandler
   If IsNumeric(Key) Then
      If (Key &gt; 0) And (Key &lt;= m_iBarCount) Then
         plBarIndex = Key
         Exit Property
      End If
   Else
      Dim i As Long
      For i = 1 To m_iBarCount
         If (m_tBar(i).sKey = Key) Then
            plBarIndex = i
            Exit Property
         End If
      Next i
   End If

errorHandler:
   Err.Raise 9, App.EXEName &amp; ".vbalToolBoxBarCtl", "Subscript out of range"
   Exit Property
   
End Property
Private Function pbCheckKey(Key As Variant) As Boolean
On Error GoTo errorHandler
   
   If IsNumeric(Key) Then
      ' invalid key
      Err.Raise 13, App.EXEName &amp; ".vbalToolBoxBarCtl"
      Exit Function
   End If
   
   Dim sKey As String
   sKey = Key
   Dim i As Long
   For i = 1 To m_iBarCount
      If (m_tBar(i).sKey = sKey) Then
         Err.Raise 457, App.EXEName &amp; ".vbalToolBoxBarCtl"
         Exit Function
      End If
   Next i
   pbCheckKey = True
   Exit Function
errorHandler:
   ' invalid key:
   Err.Raise 13, App.EXEName &amp; ".vbalToolBoxBarCtl"
   Exit Function
End Function
' ---------------------------------------
' END Bar Collection
' ---------------------------------------

' ---------------------------------------
' START Bar
' ---------------------------------------
Public Property Get SelectedBar() As cToolBoxBar
Attribute SelectedBar.VB_Description = "Gets the selected bar in the control."
   If (m_iBarCount &gt; 0) Then
      If (m_iSelBar &gt; 0) Then
         Dim cT As New cToolBoxBar
         cT.fInit ObjPtr(Me), m_hWnd, m_tBar(m_iSelBar).lId
         Set SelectedBar = cT
      End If
   End If
End Property

Private Property Get plBarForId(ByVal lId As Long) As Long
   Dim i As Long
   For i = 1 To m_iBarCount
      If (m_tBar(i).lId = lId) Then
         plBarForId = i
         Exit Property
      End If
   Next i
   Err.Raise 9, App.EXEName &amp; ".vbalToolBoxBarCtl", "Subscript out of range"
   
End Property

Friend Property Get fBarCaption(ByVal lId As Long) As String
   Dim lIndex As Long
   lIndex = plBarForId(lId)
   If (lIndex &gt; 0) Then
      fBarCaption = m_tBar(lIndex).sCaption
   End If
End Property
Friend Property Let fBarCaption(ByVal lId As Long, ByVal sCaption As String)
   Dim lIndex As Long
   lIndex = plBarForId(lId)
   If (lIndex &gt; 0) Then
      m_tBar(lIndex).sCaption = sCaption
      pDraw
   End If
End Property

Friend Property Get fBarTag(ByVal lId As Long) As String
   Dim lIndex As Long
   lIndex = plBarForId(lId)
   If (lIndex &gt; 0) Then
      fBarTag = m_tBar(lIndex).sTag
   End If
End Property
Friend Property Let fBarTag(ByVal lId As Long, ByVal sTag As String)
   Dim lIndex As Long
   lIndex = plBarForId(lId)
   If (lIndex &gt; 0) Then
      m_tBar(lIndex).sTag = sTag
   End If
End Property

Friend Property Get fBarKey(ByVal lId As Long) As String
   Dim lIndex As Long
   lIndex = plBarForId(lId)
   If (lIndex &gt; 0) Then
      fBarKey = m_tBar(lIndex).sKey
   End If
End Property
Friend Property Let fBarKey(ByVal lId As Long, ByVal sKey As String)
   Dim lIndex As Long
   lIndex = plBarForId(lId)
   If (lIndex &gt; 0) Then
      m_tBar(lIndex).sKey = sKey
   End If
End Property

Friend Property Get fBarItemData(ByVal lId As Long) As Long
   Dim lIndex As Long
   lIndex = plBarForId(lId)
   If (lIndex &gt; 0) Then
      fBarItemData = m_tBar(lIndex).lItemData
   End If
End Property
Friend Property Let fBarItemData(ByVal lId As Long, ByVal lItemData As Long)
   Dim lIndex As Long
   lIndex = plBarForId(lId)
   If (lIndex &gt; 0) Then
      m_tBar(lIndex).lItemData = lItemData
   End If
End Property

Friend Property Get fBarIndex(ByVal lId As Long) As Long
   fBarIndex = plBarForId(lId)
End Property

Friend Property Get fBarSelected(ByVal lId As Long) As Boolean
   Dim lIndex As Long
   lIndex = plBarForId(lId)
   If (lIndex &gt; 0) Then
      fBarSelected = (lIndex = m_iSelBar)
   End If
End Property
Friend Property Let fBarSelected(ByVal lId As Long, ByVal bSelected As Boolean)
   Dim lIndex As Long
   lIndex = plBarForId(lId)
   If (lIndex &gt; 0) Then
      If (bSelected) Then
         If Not (m_iSelBar = lIndex) Then
            pScrollSelect lIndex
            m_iSelBar = lIndex
            pResize
         End If
      Else
         ' doesn't really mean anything..
      End If
   End If
End Property

Friend Property Get fBarSorted(ByVal lId As Long) As Boolean
   Dim lIndex As Long
   lIndex = plBarForId(lId)
   If (lIndex &gt; 0) Then
      fBarSorted = m_tBar(lIndex).bSorted
   End If
End Property
Friend Property Let fBarSorted(ByVal lId As Long, ByVal bState As Boolean)
   Dim lIndex As Long
   lIndex = plBarForId(lId)
   If (lIndex &gt; 0) Then
      If Not (m_tBar(lIndex).bSorted = bState) Then
         m_tBar(lIndex).bSorted = bState
         If (bState) Then
            ' sort
            pBarSort lIndex
         Else
            ' return to original indexes
         End If
         pDraw
      End If
   End If
End Property

Private Function piGetSuitableShellSortInitialIncrement( _
        iSortSize As Long _
    ) As Long
' ==============================================================
' Part of the implementation of Shell Sort algorithm using
' + 1 * 3 increment strategy.  This function returns the
' largest increment based on +1*3 which is less than the
' sort size.
' ==============================================================
Dim iRet As Long
Dim iLastRet As Long
    iLastRet = 1
    iRet = 1
    Do While iRet &lt; iSortSize
        iLastRet = iRet
        iRet = iRet * 3 + 1
    Loop
    piGetSuitableShellSortInitialIncrement = iLastRet
End Function

Private Sub pBarSort(ByVal lIndex As Long)
Dim iSwapIndex As Long
Dim iIncrement As Long
Dim iMainLoop As Long
Dim iSubLoop As Long
Dim tSortItem As tBarItem
Dim iItemCount As Long
           
    iItemCount = m_tBar(lIndex).lItemCount

    ' Shell sort the list:
    ' ========================================================
    ' Implementation of Shell Sort algorithm using
    ' + 1 * 3 increment.
    ' ========================================================
    ' Get inital shell sort increment
    If (iItemCount &gt; 2) Then
        iIncrement = piGetSuitableShellSortInitialIncrement(iItemCount)
        Do Until iIncrement &lt; 1
            For iMainLoop = iIncrement + 1 To iItemCount
                ' Store iMainLoop:
                LSet tSortItem = m_tBar(lIndex).tItem(iMainLoop)
                
                ' Loop form MainLoop-Increment to 0
                For iSubLoop = (iMainLoop - iIncrement) To 1 Step -iIncrement
                    If (StrComp(m_tBar(lIndex).tItem(iSubLoop).sCaption,
                     tSortItem.sCaption, vbTextCompare) &lt;= 0) Then
                        Exit For
                    End If
                    LSet m_tBar(lIndex).tItem(iSubLoop + iIncrement) =
                     m_tBar(lIndex).tItem(iSubLoop)
                Next iSubLoop
                
                LSet m_tBar(lIndex).tItem(iSubLoop + iIncrement) = tSortItem
            Next iMainLoop
            
            ' Get next shell sort increment value:
            iIncrement = iIncrement - 1
            iIncrement = iIncrement \ 3
        Loop
    Else
        ' For only two items just check whether the second should
        ' be swapped with the first:
        '    Fix - last version caused GPF as it fell off the end
        '    of the array..
        If (iItemCount = 2) Then
            If (StrComp(m_tBar(lIndex).tItem(2).sCaption,
             m_tBar(lIndex).tItem(1).sCaption, vbTextCompare) &lt; 0) Then
               ' swap
               LSet tSortItem = m_tBar(lIndex).tItem(1)
               LSet m_tBar(lIndex).tItem(1) = m_tBar(lIndex).tItem(2)
               LSet m_tBar(lIndex).tItem(2) = tSortItem
            End If
         End If
   End If
   If (m_iSelBar = lIndex) Then
      pResizeClient m_iSelBar
   End If
End Sub

Friend Property Get fBarVisible(ByVal lId As Long) As Boolean
   Dim lIndex As Long
   lIndex = plBarForId(lId)
   If (lIndex &gt; 0) Then
      fBarVisible = m_tBar(lIndex).bVisible
   End If
End Property
Friend Property Let fBarVisible(ByVal lId As Long, ByVal bState As Boolean)
   Dim lIndex As Long
   lIndex = plBarForId(lId)
   If (lIndex &gt; 0) Then
      If Not (m_tBar(lIndex).bVisible = bState) Then
         m_tBar(lIndex).bVisible = bState
         If Not bState Then
            If (m_iSelBar = lIndex) Then
               Dim i As Long
               Dim bFound As Boolean
               ' try to find the next bar that's visible downwards:
               For i = m_iSelBar + 1 To m_iBarCount
                  If (m_tBar(i).bVisible) Then
                     m_iSelBar = i
                     bFound = True
                     Exit For
                  End If
               Next i
               ' if no good, then look up:
               If Not (bFound) Then
                  For i = m_iSelBar - 1 To 1 Step -1
                     If (m_tBar(i).bVisible) Then
                        m_iSelBar = i
                        bFound = True
                        Exit For
                     End If
                  Next i
               End If
               If Not (bFound) Then
                  m_iSelBar = 0
               End If
            End If
         End If
         pResize
      End If
   End If
End Property


Friend Property Get fBarListStyle(ByVal lId As Long) As Boolean
   Dim lIndex As Long
   lIndex = plBarForId(lId)
   If (lIndex &gt; 0) Then
      fBarListStyle = m_tBar(lIndex).bListView
   End If
End Property
Friend Property Let fBarListStyle(ByVal lId As Long, ByVal bListStyle As
 Boolean)
   Dim lIndex As Long
   lIndex = plBarForId(lId)
   If (lIndex &gt; 0) Then
      If Not (m_tBar(lIndex).bListView = bListStyle) Then
         m_tBar(lIndex).bListView = bListStyle
         pResize
      End If
   End If
End Property

Friend Property Get fBarItems(ByVal lBarId As Long) As cToolItemCollection
Dim i As Long
   For i = 1 To m_iBarCount
      If (m_tBar(i).lId = lBarId) Then
         Dim cT As New cToolItemCollection
         cT.fInit ObjPtr(Me), m_hWnd, lBarId
         Set fBarItems = cT
         Exit Property
      End If
   Next i
End Property
Friend Property Get fItemCount(ByVal lBarId As Long) As Long
Dim lIndex As Long
   lIndex = plBarForId(lBarId)
   If (lIndex &gt; 0) Then
      fItemCount = m_tBar(lIndex).lItemCount
   End If
End Property
' ---------------------------------------
' END Bar
' ---------------------------------------

' ---------------------------------------
' Start BarItems
' ---------------------------------------
Friend Property Get fSelectedItem(ByVal lBarId As Long) As cToolItem
Dim lIndex As Long
   lIndex = plBarForId(lBarId)
   If (lIndex &gt; 0) Then
      Dim i As Long
      For i = 1 To m_tBar(lIndex).lItemCount
         If (m_tBar(lIndex).tItem(i).bSelected) Then
            Dim cT As New cToolItem
            cT.fInit ObjPtr(Me), m_hWnd, m_tBar(lIndex).lId,
             m_tBar(lIndex).tItem(i).lId
            Set fSelectedItem = cT
         End If
      Next i
   End If
End Property

Friend Property Get fItem(ByVal lBarId As Long, Key As Variant) As cToolItem
Dim lIndex As Long
Dim lBarIndex As Long
   lBarIndex = plBarForId(lBarId)
   If (lBarIndex &gt; 0) Then
      lIndex = plItemIndex(lBarIndex, Key)
      If (lIndex &gt; 0) Then
         Dim cT As New cToolItem
         cT.fInit ObjPtr(Me), m_hWnd, lBarId,
          m_tBar(lBarIndex).tItem(lIndex).lId
         Set fItem = cT
      End If
   End If
End Property
Friend Sub fItemRemove(ByVal lBarId As Long, Key As Variant)
Dim lBarIndex As Long
Dim lIndex As Long
   lBarIndex = plBarForId(lBarId)
   If (lBarIndex &gt; 0) Then
      lIndex = plItemIndex(lBarIndex, Key)
      If (lIndex &gt; 0) Then
         If (m_tBar(lBarIndex).lItemCount &lt;= 1) Then
            m_tBar(lBarIndex).lItemCount = 0
         Else
            Dim i As Long
            For i = lIndex To m_tBar(lBarIndex).lItemCount - 1
               LSet m_tBar(lBarIndex).tItem(i) = m_tBar(lBarIndex).tItem(i + 1)
            Next i
            m_tBar(lBarIndex).lItemCount = m_tBar(lBarIndex).lItemCount - 1
         End If
         If (lBarIndex = m_iSelBar) Then
            pResize
         End If
      End If
   End If
End Sub
Friend Function fItemAdd( _
      ByVal lBarId As Long, _
      Optional Key As Variant, _
      Optional KeyBefore As Variant, _
      Optional Caption As String, _
      Optional IconIndex As Long _
   ) As cToolItem
Dim lBarIndex As Long
   lBarIndex = plBarForId(lBarId)
   If (lBarIndex &gt; 0) Then
      If (pbCheckItemKey(lBarIndex, Key)) Then
         
         ' Prepare position to put the new bar:
         Dim lIndex As Long
         If Not IsMissing(KeyBefore) Then
            lIndex = plItemIndex(lBarIndex, Key)
            If (lIndex &lt;= 0) Then
               Exit Function
            End If
            If (m_tBar(lBarIndex).bSorted) Then
               m_tBar(lBarIndex).bSorted = False
            End If
            ' shift things down:
            ReDim Preserve m_tBar(lBarIndex).tItem(1 To
             m_tBar(lBarIndex).lItemCount + 1) As tBarItem
            Dim i As Long
            For i = m_tBar(lBarIndex).lItemCount To lIndex Step -1
               LSet m_tBar(lBarIndex).tItem(i + 1) = m_tBar(lBarIndex).tItem(i)
            Next i
            m_tBar(lBarIndex).lItemCount = m_tBar(lBarIndex).lItemCount + 1
         Else
            ReDim Preserve m_tBar(lBarIndex).tItem(1 To
             m_tBar(lBarIndex).lItemCount + 1) As tBarItem
            If (m_tBar(lBarIndex).bSorted) And Len(Caption) &gt; 0 Then
               ' find the position:
               For i = 1 To m_tBar(lBarIndex).lItemCount
                  If (StrComp(Caption, m_tBar(lBarIndex).tItem(i).sCaption,
                   vbTextCompare) &lt;= 0) Then
                     lIndex = i
                     Exit For
                  End If
               Next i
               If (lIndex &gt; 0) Then
                  ' Shift everything from lIndex to end down:
                  For i = m_tBar(lBarIndex).lItemCount To lIndex Step -1
                     LSet m_tBar(lBarIndex).tItem(i + 1) =
                      m_tBar(lBarIndex).tItem(i)
                  Next i
               Else
                  lIndex = m_tBar(lBarIndex).lItemCount
               End If
               m_tBar(lBarIndex).lItemCount = m_tBar(lBarIndex).lItemCount + 1
            Else
               ' Add at the end:
               m_tBar(lBarIndex).lItemCount = m_tBar(lBarIndex).lItemCount + 1
               lIndex = m_tBar(lBarIndex).lItemCount
            End If
         End If

         ' add the item
         m_lItemIdGenerator = m_lItemIdGenerator + 1
         With m_tBar(lBarIndex).tItem(lIndex)
            .lId = m_lItemIdGenerator
            If Not IsMissing(Caption) Then
               .sCaption = Caption
            End If
            If Not IsMissing(Key) Then
               .sKey = Key
            End If
            If Not IsMissing(IconIndex) Then
               .lIconIndex = IconIndex
            End If
            .bEnabled = True
            .bCanDrag = True
         End With
         If (m_tBar(lBarIndex).lItemCount = 1) Then
            m_tBar(lBarIndex).tItem(1).bSelected = True
         End If
         If (lBarIndex = m_iSelBar) Then
            pResize
         End If
         
         Dim cT As New cToolItem
         cT.fInit ObjPtr(Me), m_hWnd, lBarId,
          m_tBar(lBarIndex).tItem(lIndex).lId
         Set fItemAdd = cT
      End If
   End If
End Function

Friend Property Get fItemCaption(ByVal lBarId As Long, ByVal lId As Long) As
 String
Dim lBarIndex As Long
   lBarIndex = plBarForId(lBarId)
   If (lBarIndex &gt; 0) Then
      Dim lIndex As Long
      lIndex = plItemForId(lBarIndex, lId)
      If (lIndex &gt; 0) Then
         fItemCaption = m_tBar(lBarIndex).tItem(lIndex).sCaption
      End If
   End If
End Property
Friend Property Let fItemCaption(ByVal lBarId As Long, ByVal lId As Long, ByVal
 sCaption As String)
Dim lBarIndex As Long
   lBarIndex = plBarForId(lBarId)
   If (lBarIndex &gt; 0) Then
      Dim lIndex As Long
      lIndex = plItemForId(lBarIndex, lId)
      If (lIndex &gt; 0) Then
         m_tBar(lBarIndex).tItem(lIndex).sCaption = sCaption
         If (m_tBar(lBarIndex).bSorted) Then
            ' sort the bar:
            pBarSort lBarIndex
         End If
         pDraw
      End If
   End If
End Property

Friend Property Get fNextItem(ByVal lBarId As Long, ByVal lId As Long, ByVal
 iDir As Long) As cToolItem
Dim lBarIndex As Long
   
   lBarIndex = plBarForId(lBarId)
   If (lBarIndex &gt; 0) Then
      Dim lIndex As Long
      lIndex = plItemForId(lBarIndex, lId)
      If (lIndex &gt; 0) Then
         Dim cT As cToolItem
         If (iDir &gt; 0) Then
            If (lIndex &lt; m_tBar(lBarIndex).lItemCount) Then
               Set cT = New cToolItem
               cT.fInit ObjPtr(Me), m_hWnd, lBarId,
                m_tBar(lBarIndex).tItem(lIndex + 1).lId
               Set fNextItem = cT
            End If
         Else
            If (lIndex &gt; 1) Then
               Set cT = New cToolItem
               cT.fInit ObjPtr(Me), m_hWnd, lBarId,
                m_tBar(lBarIndex).tItem(lIndex - 1).lId
               Set fNextItem = cT
            End If
         End If
      End If
   End If
   
End Property

Friend Sub fItemMove(ByVal lBarId As Long, ByVal lId As Long, ByVal iDir As
 Long)
Dim lBarIndex As Long
   
   lBarIndex = plBarForId(lBarId)
   If (lBarIndex &gt; 0) Then
      Dim lIndex As Long
      lIndex = plItemForId(lBarIndex, lId)
      If (lIndex &gt; 0) Then
         Dim cT As cToolItem
         Set cT = fNextItem(lBarId, lId, iDir)
         If Not cT Is Nothing Then
            Dim tSwap As tBarItem
            Dim lSwapIndex As Long
            lSwapIndex = cT.Index
            LSet tSwap = m_tBar(lBarIndex).tItem(lIndex)
            LSet m_tBar(lBarIndex).tItem(lIndex) =
             m_tBar(lBarIndex).tItem(lSwapIndex)
            LSet m_tBar(lBarIndex).tItem(lSwapIndex) = tSwap
            If (lBarIndex = m_iSelBar) Then
               pResizeClient m_iSelBar
               pScrollIntoView lSwapIndex
            End If
         End If
      End If
   End If
End Sub


Friend Property Get fItemKey(ByVal lBarId As Long, ByVal lId As Long) As String
Dim lBarIndex As Long
   lBarIndex = plBarForId(lBarId)
   If (lBarIndex &gt; 0) Then
      Dim lIndex As Long
      lIndex = plItemForId(lBarIndex, lId)
      If (lIndex &gt; 0) Then
         fItemKey = m_tBar(lBarIndex).tItem(lIndex).sKey
      End If
   End If
End Property
Friend Property Let fItemKey(ByVal lBarId As Long, ByVal lId As Long, ByVal
 sKey As String)
Dim lBarIndex As Long
   lBarIndex = plBarForId(lBarId)
   If (lBarIndex &gt; 0) Then
      Dim lIndex As Long
      lIndex = plItemForId(lBarIndex, lId)
      If (lIndex &gt; 0) Then
         m_tBar(lBarIndex).tItem(lIndex).sKey = sKey
      End If
   End If
End Property

Friend Property Get fItemIndex(ByVal lBarId As Long, ByVal lId As Long) As Long
Dim lBarIndex As Long
   lBarIndex = plBarForId(lBarId)
   If (lBarIndex &gt; 0) Then
      fItemIndex = plItemForId(lBarIndex, lId)
   End If
End Property

Friend Property Get fItemTag(ByVal lBarId As Long, ByVal lId As Long) As String
Dim lBarIndex As Long
   lBarIndex = plBarForId(lBarId)
   If (lBarIndex &gt; 0) Then
      Dim lIndex As Long
      lIndex = plItemForId(lBarIndex, lId)
      If (lIndex &gt; 0) Then
         fItemTag = m_tBar(lBarIndex).tItem(lIndex).sTag
      End If
   End If
End Property
Friend Property Let fItemTag(ByVal lBarId As Long, ByVal lId As Long, ByVal
 sTag As String)
Dim lBarIndex As Long
   lBarIndex = plBarForId(lBarId)
   If (lBarIndex &gt; 0) Then
      Dim lIndex As Long
      lIndex = plItemForId(lBarIndex, lId)
      If (lIndex &gt; 0) Then
         m_tBar(lBarIndex).tItem(lIndex).sTag = sTag
      End If
   End If
End Property

Friend Property Get fItemData(ByVal lBarId As Long, ByVal lId As Long) As Long
Dim lBarIndex As Long
   lBarIndex = plBarForId(lBarId)
   If (lBarIndex &gt; 0) Then
      Dim lIndex As Long
      lIndex = plItemForId(lBarIndex, lId)
      If (lIndex &gt; 0) Then
         fItemData = m_tBar(lBarIndex).tItem(lIndex).lItemData
      End If
   End If
End Property
Friend Property Let fItemData(ByVal lBarId As Long, ByVal lId As Long, ByVal
 lItemData As Long)
Dim lBarIndex As Long
   lBarIndex = plBarForId(lBarId)
   If (lBarIndex &gt; 0) Then
      Dim lIndex As Long
      lIndex = plItemForId(lBarIndex, lId)
      If (lIndex &gt; 0) Then
         m_tBar(lBarIndex).tItem(lIndex).lItemData = lItemData
      End If
   End If
End Property

Friend Property Get fItemEnabled(ByVal lBarId As Long, ByVal lId As Long) As
 Boolean
Dim lBarIndex As Long
   lBarIndex = plBarForId(lBarId)
   If (lBarIndex &gt; 0) Then
      Dim lIndex As Long
      lIndex = plItemForId(lBarIndex, lId)
      If (lIndex &gt; 0) Then
         fItemEnabled = m_tBar(lBarIndex).tItem(lIndex).bEnabled
      End If
   End If
End Property
Friend Property Let fItemEnabled(ByVal lBarId As Long, ByVal lId As Long, ByVal
 bEnabled As Boolean)
Dim lBarIndex As Long
   lBarIndex = plBarForId(lBarId)
   If (lBarIndex &gt; 0) Then
      Dim lIndex As Long
      lIndex = plItemForId(lBarIndex, lId)
      If (lIndex &gt; 0) Then
         m_tBar(lBarIndex).tItem(lIndex).bEnabled = bEnabled
         pDraw
      End If
   End If
End Property

Friend Sub fItemEnsureVisible(ByVal lBarId As Long, ByVal lId As Long)
Dim lBarIndex As Long
   lBarIndex = plBarForId(lBarId)
   If (lBarIndex &gt; 0) Then
      Dim lIndex As Long
      lIndex = plItemForId(lBarIndex, lId)
      If (lIndex &gt; 0) Then
         pScrollIntoView lIndex
      End If
   End If
End Sub


Friend Property Get fItemCanDrag(ByVal lBarId As Long, ByVal lId As Long) As
 Boolean
Dim lBarIndex As Long
   lBarIndex = plBarForId(lBarId)
   If (lBarIndex &gt; 0) Then
      Dim lIndex As Long
      lIndex = plItemForId(lBarIndex, lId)
      If (lIndex &gt; 0) Then
         fItemCanDrag = m_tBar(lBarIndex).tItem(lIndex).bCanDrag
      End If
   End If
End Property
Friend Property Let fItemCanDrag(ByVal lBarId As Long, ByVal lId As Long, ByVal
 bCanDrag As Boolean)
Dim lBarIndex As Long
   lBarIndex = plBarForId(lBarId)
   If (lBarIndex &gt; 0) Then
      Dim lIndex As Long
      lIndex = plItemForId(lBarIndex, lId)
      If (lIndex &gt; 0) Then
         m_tBar(lBarIndex).tItem(lIndex).bCanDrag = bCanDrag
         pDraw
      End If
   End If
End Property

Friend Property Get fItemSelected(ByVal lBarId As Long, ByVal lId As Long) As
 Boolean
Dim lBarIndex As Long
   lBarIndex = plBarForId(lBarId)
   If (lBarIndex &gt; 0) Then
      Dim lIndex As Long
      lIndex = plItemForId(lBarIndex, lId)
      If (lIndex &gt; 0) Then
         fItemSelected = m_tBar(lBarIndex).tItem(lIndex).bSelected
      End If
   End If
End Property
Friend Property Let fItemSelected(ByVal lBarId As Long, ByVal lId As Long,
 ByVal bSelected As Boolean)
Dim lBarIndex As Long
   lBarIndex = plBarForId(lBarId)
   If (lBarIndex &gt; 0) Then
      Dim lIndex As Long
      lIndex = plItemForId(lBarIndex, lId)
      If (lIndex &gt; 0) Then
         If bSelected Then
            If Not m_tBar(lBarIndex).tItem(lIndex).bSelected Then
               Dim i As Long
               For i = 1 To m_tBar(lBarIndex).lItemCount
                  m_tBar(lBarIndex).tItem(i).bSelected = (i = lIndex)
                  If (i = lIndex) Then
                     If (lBarIndex = m_iSelBar) Then
                        pScrollIntoView lIndex
                     End If
                  End If
               Next i
            End If
         End If
      End If
   End If
End Property

Private Function pbCheckItemKey(ByVal lBarIndex As Long, Key As Variant) As
 Boolean
On Error GoTo errorHandler
   
   If IsNumeric(Key) Then
      ' invalid key
      Err.Raise 13, App.EXEName &amp; ".vbalToolBoxBarCtl"
      Exit Function
   End If
   
   Dim sKey As String
   sKey = Key
   Dim i As Long
   Dim j As Long
   For j = 1 To m_iBarCount
      For i = 1 To m_tBar(j).lItemCount
         If (m_tBar(j).tItem(i).sKey = sKey) Then
            Err.Raise 457, App.EXEName &amp; ".vbalToolBoxBarCtl"
            Exit Function
         End If
      Next i
   Next j
   pbCheckItemKey = True
   Exit Function
   
errorHandler:
   ' invalid key:
   Err.Raise 13, App.EXEName &amp; ".vbalToolBoxBarCtl"
   Exit Function

End Function

Private Property Get plItemIndex(ByVal lBarIndex As Long, Key As Variant) As
 Long
On Error GoTo errorHandler
   If IsNumeric(Key) Then
      If (Key &gt; 0) And (Key &lt;= m_tBar(lBarIndex).lItemCount) Then
         plItemIndex = Key
         Exit Property
      End If
   Else
      Dim i As Long
      For i = 1 To m_tBar(lBarIndex).lItemCount
         If (m_tBar(lBarIndex).tItem(i).sKey = Key) Then
            plItemIndex = i
            Exit Property
         End If
      Next i
   End If

errorHandler:
   Err.Raise 9, App.EXEName &amp; ".vbalToolBoxBarCtl", "Subscript out of range"
   Exit Property
   
End Property

Private Property Get plItemForId(ByVal lBarIndex As Long, ByVal lId As Long) As
 Long
   Dim i As Long
   For i = 1 To m_tBar(lBarIndex).lItemCount
      If (m_tBar(lBarIndex).tItem(i).lId = lId) Then
         plItemForId = i
         Exit Property
      End If
   Next i
   Err.Raise 9, App.EXEName &amp; ".vbalToolBoxBarCtl", "Subscript out of range"
   
End Property

' ---------------------------------------
' End BarItems
' ---------------------------------------



Private Sub pResize()

   Dim tR As RECT
   GetClientRect m_hWnd, tR
   m_cMemDC.Width = tR.right - tR.Left
   m_cMemDC.Height = tR.bottom - tR.Top

   If (m_iBarCount &gt; 0) Then
      Dim iAbove As Long
      Dim iBelow As Long
      Dim iItemAfterSel As Long
      Dim bOneVisible As Boolean
      Dim i As Long
      
      For i = 1 To m_iBarCount
         If m_tBar(i).bVisible Then
            bOneVisible = True
            Exit For
         End If
      Next i
      
      If Not bOneVisible Then
         For i = 1 To m_iBarCount
            With m_tBar(i).tCaptionR
               .Left = 0
               .right = 0
               .Top = 0
               .bottom = 0
            End With
            pDraw
         Next i
         
         Exit Sub
      End If
      
      iAbove = m_iSelBar
      iBelow = m_iBarCount - m_iSelBar
         
      ' Position the bar captions:
      Dim lTop As Long
      For i = 1 To iAbove
         With m_tBar(i)
            If (.bVisible) Then
               With .tCaptionR
                  .Left = tR.Left
                  .right = tR.right
                  .Top = lTop
                  .bottom = .Top + m_lCaptionHeight
                  lTop = .bottom
               End With
               If (i = m_iSelBar) Then
                  .tScrollUpR.right = .tCaptionR.right
                  .tScrollUpR.Left = .tScrollUpR.right - (.tCaptionR.bottom -
                   .tCaptionR.Top)
                  .tScrollUpR.Top = .tCaptionR.Top
                  .tScrollUpR.bottom = .tCaptionR.bottom
                  .tCaptionR.right = .tScrollUpR.Left
               End If
            Else
               With .tCaptionR
                  .Left = 0
                  .right = 0
                  .Top = 0
                  .bottom = 0
               End With
            End If
         End With
      Next i
      
      Dim lBottom As Long
      If (tR.bottom - tR.Top - lTop &gt; m_lCaptionHeight * iBelow) Then
         lBottom = tR.bottom
      Else
         lBottom = lTop + m_lCaptionHeight * iBelow
      End If
      
      iItemAfterSel = m_iBarCount + 1
      For i = m_iBarCount To m_iSelBar + 1 Step -1
         If (m_tBar(i).bVisible) Then
            iItemAfterSel = i
         End If
      Next i
      
      If (iItemAfterSel = m_iBarCount + 1) Then
         With m_tBar(m_iSelBar)
            LSet .tScrollDownR = .tScrollUpR
            .tScrollDownR.bottom = tR.bottom
            .tScrollDownR.Top = tR.bottom - (.tScrollUpR.bottom -
             .tScrollUpR.Top)
         End With
      Else
         For i = m_iBarCount To m_iSelBar + 1 Step -1
            With m_tBar(i)
               If (.bVisible) Then
                  With .tCaptionR
                     .Left = tR.Left
                     .right = tR.right
                     .bottom = lBottom
                     .Top = .bottom - m_lCaptionHeight
                     lBottom = .Top
                  End With
                  If (i = iItemAfterSel) Then
                     m_tBar(m_iSelBar).tScrollDownR.right = .tCaptionR.right
                     m_tBar(m_iSelBar).tScrollDownR.Left =
                      m_tBar(m_iSelBar).tScrollDownR.right - (.tCaptionR.bottom
                      - .tCaptionR.Top)
                     m_tBar(m_iSelBar).tScrollDownR.Top = .tCaptionR.Top
                     m_tBar(m_iSelBar).tScrollDownR.bottom = .tCaptionR.bottom
                     .tCaptionR.right = m_tBar(m_iSelBar).tScrollDownR.Left
                  End If
               Else
                  With .tCaptionR
                     .Left = 0
                     .right = 0
                     .Top = 0
                     .bottom = 0
                  End With
               End If
            End With
         Next i
      End If
      
      ' Determine the client rectangle:
      If (m_iSelBar &gt; 0) Then
         With m_tBar(m_iSelBar)
            .tClientR.Left = .tCaptionR.Left
            .tClientR.right = tR.right
            .tClientR.Top = .tCaptionR.bottom
            If (iItemAfterSel = m_iBarCount + 1) Then
               .tClientR.bottom = tR.bottom - m_lCaptionHeight
               If (.tClientR.bottom &lt; .tCaptionR.bottom) Then
                  .tClientR.bottom = .tCaptionR.bottom
               End If
            Else
               .tClientR.bottom = m_tBar(iItemAfterSel).tCaptionR.Top
            End If
         End With
      End If
      ' Resize the items inside the selected client:
      pResizeClient m_iSelBar
      
      
   End If
   pDraw
   
End Sub

Private Sub pResizeClient(ByVal iSelBar As Long)
   '
   Dim i As Long
   Dim x As Long
   Dim y As Long
   
   With m_tBar(iSelBar)
      x = .tClientR.Left
      y = .tClientR.Top
      
      m_lItemHeight = m_lIconHeight + 6
      If (.bListView) Then
         If (m_lItemHeight &lt; m_lCaptionHeight) Then
            m_lItemHeight = m_lCaptionHeight
         End If
      End If
   
      For i = 1 To .lItemCount
         If (.bListView) Then
            ' each item on a new line
            .tItem(i).tR.Left = x
            .tItem(i).tR.Top = y
            .tItem(i).tR.right = .tClientR.right
            .tItem(i).tR.bottom = y + m_lItemHeight
            y = .tItem(i).tR.bottom
         Else
            ' items follow each other
            .tItem(i).tR.Left = x
            .tItem(i).tR.Top = y
            .tItem(i).tR.right = x + m_lIconWidth + 6
            .tItem(i).tR.bottom = y + m_lItemHeight
            If (x + (m_lIconWidth + 6) * 2) &gt; .tClientR.right Then
               x = .tClientR.Left
               y = y + m_lItemHeight
            Else
               x = x + m_lIconWidth + 6
            End If
         End If
      Next i
      
      If (.lItemCount &gt; 0) Then
         .lSize = .tItem(.lItemCount).tR.bottom - .tClientR.Top
      Else
         .lSize = 0
      End If
      
      If (.lOffset &lt; 0) Then
         ' check if any space:
         If (.tItem(.lItemCount).tR.bottom + .lOffset &lt; .tClientR.bottom) Then
            Dim bComplete As Boolean
            Dim lNextOffset As Long
            Do While Not bComplete
               lNextOffset = .lOffset + m_lItemHeight
               If (.tItem(.lItemCount).tR.bottom + lNextOffset &lt;
                .tClientR.bottom) Then
                  .lOffset = lNextOffset
               Else
                  bComplete = True
               End If
               If (.lOffset &gt; 0) Then
                  .lOffset = 0
                  bComplete = True
               End If
            Loop
         End If
      End If
      
   End With
   '
End Sub

Private Sub pDraw()
   Dim tR As RECT
   GetClientRect m_hWnd, tR
   
   Dim lHDC As Long
   lHDC = m_cMemDC.hdc
   
   Dim hBrBack As Long
   Dim hFontOld As Long
   hBrBack = CreateSolidBrush(TranslateColor(m_oBackColor))
   FillRect lHDC, tR, hBrBack
   
   If (m_iBarCount &gt; 0) Then
      
      hFontOld = SelectObject(lHDC, m_fnt.hFont)
         
      ' Draw the client:
      If (m_iSelBar &gt; 0) Then
         SetTextColor lHDC, TranslateColor(m_oForeColor)
         pDrawClient lHDC
      End If
      
      ' Draw the captions:
      Dim i As Long
      Dim tCapR As RECT
      Dim tFillR As RECT
      Dim hPenLight As Long
      Dim hPenShadow As Long
      Dim hPenOld As Long
      Dim tJunk As POINTAPI
      Dim hBr As Long
      
      hPenLight = CreatePen(PS_SOLID, 1, GetSysColor(vb3DHighlight And &amp;H1F&amp;))
      hPenShadow = CreatePen(PS_SOLID, 1, GetSysColor(vbButtonShadow And &amp;H1F&amp;))
      
      For i = 1 To m_iBarCount
         LSet tCapR = m_tBar(i).tCaptionR
         tCapR.Left = tCapR.Left + 1
         tCapR.Top = tCapR.Top + 1
         tCapR.bottom = tCapR.bottom - 1
         tCapR.right = tCapR.right - 1
         LSet tFillR = tCapR
         tFillR.right = tR.right
         FillRect lHDC, tFillR, hBrBack
                           
         If (m_tBar(i).bDown And (m_tBar(i).bTrack)) Then
            hPenOld = SelectObject(lHDC, hPenShadow)
         Else
            hPenOld = SelectObject(lHDC, hPenLight)
         End If
         MoveToEx lHDC, tCapR.Left, tCapR.bottom - 1, tJunk
         LineTo lHDC, tCapR.Left, tCapR.Top
         LineTo lHDC, tCapR.right - 1, tCapR.Top
         SelectObject lHDC, hPenOld
         If (m_tBar(i).bDown And (m_tBar(i).bTrack)) Then
            hPenOld = SelectObject(lHDC, hPenLight)
         Else
            hPenOld = SelectObject(lHDC, hPenShadow)
         End If
         MoveToEx lHDC, tCapR.right - 1, tCapR.Top + 1, tJunk
         LineTo lHDC, tCapR.right - 1, tCapR.bottom - 1
         LineTo lHDC, tCapR.Left - 1, tCapR.bottom - 1
         SelectObject lHDC, hPenOld
         
         SetBkMode lHDC, TRANSPARENT
         If (i = m_iDragBar) Then
            Dim tDragBarR As RECT
            tDragBarR.Left = tCapR.Left + 1
            tDragBarR.Top = tCapR.Top + 1
            tDragBarR.bottom = tCapR.bottom - 1
            tDragBarR.right = tCapR.right - 1
            hBr = GetSysColorBrush(vb3DDKShadow And &amp;H1F&amp;)
            FillRect lHDC, tDragBarR, hBr
            DeleteObject hBr
            SetTextColor lHDC, GetSysColor(vb3DHighlight And &amp;H1F&amp;)
         Else
            SetTextColor lHDC, TranslateColor(m_oForeColor)
         End If
         Dim tTextR As RECT
         LSet tTextR = tCapR
         If (m_tBar(i).bDown And (m_tBar(i).bTrack)) Then
            OffsetRect tTextR, 1, 1
         End If
         If (m_bIsNT) Then
            DrawTextW lHDC, StrPtr(" " &amp; m_tBar(i).sCaption), -1, tTextR,
             DT_SINGLELINE Or DT_LEFT Or DT_VCENTER Or DT_WORD_ELLIPSIS
         Else
            DrawText lHDC, " " &amp; m_tBar(i).sCaption, -1, tTextR, DT_SINGLELINE
             Or DT_LEFT Or DT_VCENTER Or DT_WORD_ELLIPSIS
         End If
         
      Next i
      
      SelectObject lHDC, hFontOld
      DeleteObject hPenLight
      DeleteObject hPenShadow
      
      ' Draw scroll items:
      pDrawScrollButtons lHDC
      
   End If
   DeleteObject hBrBack
   
   BitBlt UserControl.hdc, 0, 0, tR.right - tR.Left, tR.bottom - tR.Top,
    m_cMemDC.hdc, 0, 0, vbSrcCopy
   
End Sub

Private Sub pDrawClient(ByVal lHDC As Long)
   
   Dim i As Long
   Dim tR As RECT
   Dim bListStyle As Boolean
   Dim hBr As Long
   Dim hPenLight As Long
   Dim hPenShadow As Long
   Dim hPenOld As Long
   Dim tJunk As POINTAPI
   
   With m_tBar(m_iSelBar)
      
      bListStyle = .bListView
   
      For i = 1 To .lItemCount
      
         ' Get the rectangle:
         LSet tR = .tItem(i).tR
         tR.Left = tR.Left + 1
         tR.right = tR.right - 1
         tR.Top = tR.Top + 1
         tR.bottom = tR.bottom - 1
         
         OffsetRect tR, 0, .lOffset
         
         If (tR.Top &gt; .tClientR.bottom) Then
            Exit For
         End If
         
         If (tR.bottom &gt;= .tClientR.Top) Then
                  
            ' Draw the icon:
            With .tItem(i)
               ' Draw selection:
               If (.bSelected) Then
                  If (.bTrack) Then
                     hBr = CreateSolidBrush(TranslateColor(m_oBackColor))
                  Else
                     hBr = CreateSolidBrush(SlightlyLighterColour(m_oBackColor))
                  End If
                  FillRect lHDC, tR, hBr
                  DeleteObject hBr
               End If
               
               If (.bSelected Or .bDown Or .bTrack) Then
                  hPenLight = CreatePen(PS_SOLID, 1, GetSysColor(vb3DHighlight
                   And &amp;H1F&amp;))
                  hPenShadow = CreatePen(PS_SOLID, 1,
                   GetSysColor(vbButtonShadow And &amp;H1F&amp;))

                  If ((.bDown And .bTrack) Or .bSelected) Then
                     hPenOld = SelectObject(lHDC, hPenShadow)
                  Else
                     hPenOld = SelectObject(lHDC, hPenLight)
                  End If
                  MoveToEx lHDC, tR.Left, tR.bottom - 1, tJunk
                  LineTo lHDC, tR.Left, tR.Top
                  LineTo lHDC, tR.right - 1, tR.Top
                  SelectObject lHDC, hPenOld
                  If ((.bDown And .bTrack) Or .bSelected) Then
                     hPenOld = SelectObject(lHDC, hPenLight)
                  Else
                     hPenOld = SelectObject(lHDC, hPenShadow)
                  End If
                  MoveToEx lHDC, tR.right - 1, tR.Top + 1, tJunk
                  LineTo lHDC, tR.right - 1, tR.bottom - 1
                  LineTo lHDC, tR.Left - 1, tR.bottom - 1
                  SelectObject lHDC, hPenOld

                  DeleteObject hPenLight
                  DeleteObject hPenShadow

               End If
               
               If (i = m_iDragOverItem) Then
                  Dim tDragBarR As RECT
                  tDragBarR.Left = tR.Left + 1
                  tDragBarR.Top = tR.Top + 1
                  tDragBarR.bottom = tR.bottom - 1
                  tDragBarR.right = tR.right - 1
                  hBr = GetSysColorBrush(vb3DDKShadow And &amp;H1F&amp;)
                  FillRect lHDC, tDragBarR, hBr
                  DeleteObject hBr
                  SetTextColor lHDC, GetSysColor(vb3DHighlight And &amp;H1F&amp;)
               Else
                  If (.bEnabled) Then
                     SetTextColor lHDC, TranslateColor(m_oForeColor)
                  Else
                     SetTextColor lHDC, GetSysColor(vbButtonShadow And &amp;H1F&amp;)
                  End If
               End If
            
               If (.lIconIndex &gt; -1) Then
                  If (.bEnabled) Then
                     ImageListDrawIcon m_ptrVb6ImageList, lHDC, m_hIml, _
                        .lIconIndex, _
                        tR.Left + (tR.bottom - tR.Top - m_lIconWidth) \ 2 +
                         Abs(.bSelected), _
                        tR.Top + (tR.bottom - tR.Top - m_lIconHeight) \ 2 +
                         Abs(.bSelected), (i = m_iDragOverItem)
                  Else
                     ImageListDrawIconDisabled m_ptrVb6ImageList, lHDC, m_hIml,
                      _
                        .lIconIndex, _
                        tR.Left + (tR.bottom - tR.Top - m_lIconWidth) \ 2 +
                         Abs(.bSelected), _
                        tR.Top + (tR.bottom - tR.Top - m_lIconHeight) \ 2 +
                         Abs(.bSelected), _
                        m_lIconWidth
                  End If
               End If
               
               ' Draw text if available:
               If (bListStyle) Then
                  Dim tTextR As RECT
                  LSet tTextR = tR
                  tTextR.Left = tTextR.Left + m_lIconWidth + 6
                  If (.bSelected) Then
                     OffsetRect tTextR, 1, 1
                  End If
                  If (m_bIsNT) Then
                     DrawTextW lHDC, StrPtr(" " &amp; .sCaption), -1, tTextR,
                      DT_SINGLELINE Or DT_LEFT Or DT_VCENTER Or DT_WORD_ELLIPSIS
                  Else
                     DrawText lHDC, " " &amp; .sCaption, -1, tTextR, DT_SINGLELINE
                      Or DT_LEFT Or DT_VCENTER Or DT_WORD_ELLIPSIS
                  End If
               End If
                              
            End With
            
            
         End If
      Next i
   End With
   
End Sub

Private Sub pDrawScrollButtons(Optional ByVal lHDC As Long = 0)
Dim bEnable As Boolean
   
   If (m_iSelBar &gt; 0) Then
   bEnable = (m_tBar(m_iSelBar).lOffset &lt; 0)
   pDrawOneScrollButton lHDC, _
      m_tBar(m_iSelBar).tScrollUpR, _
      bEnable, _
      m_tBar(m_iSelBar).bTrackScrollUp, _
      m_tBar(m_iSelBar).bDownScrollUp, _
      1
      
   bEnable = False
   If ((m_tBar(m_iSelBar).lSize + m_tBar(m_iSelBar).lOffset) &gt; _
         (m_tBar(m_iSelBar).tClientR.bottom - m_tBar(m_iSelBar).tClientR.Top))
          Then
      bEnable = True
   End If
   pDrawOneScrollButton lHDC, _
      m_tBar(m_iSelBar).tScrollDownR, _
      bEnable, _
      m_tBar(m_iSelBar).bTrackScrollDown, _
      m_tBar(m_iSelBar).bDownScrollDown, _
      2
   End If
End Sub

Private Sub pDrawOneScrollButton( _
      ByVal lHDC As Long, _
      tR As RECT, _
      ByVal bEnabled As Boolean, _
      ByVal bTracking As Boolean, _
      ByVal bDown As Boolean, _
      ByVal iButton As Long _
   )
Dim bPressed As Boolean
   
   If bEnabled Then
      If (bTracking And bDown) Then
         bPressed = True
      End If
   End If
   
   Dim hPenLight As Long
   Dim hPenShadow As Long
   Dim hPenOld As Long
   Dim tJunk As POINTAPI
   Dim hFontOld As Long
   Dim tBR As RECT
   
   LSet tBR = tR
   tBR.Left = tBR.Left + 1
   tBR.Top = tBR.Top + 1
   tBR.bottom = tBR.bottom - 1
   tBR.right = tBR.right - 1
   
   ' Draw outline:
   hPenLight = CreatePen(PS_SOLID, 1, GetSysColor(vb3DHighlight And &amp;H1F&amp;))
   hPenShadow = CreatePen(PS_SOLID, 1, GetSysColor(vbButtonShadow And &amp;H1F&amp;))
   
   If (bPressed) Then
      hPenOld = SelectObject(lHDC, hPenShadow)
   Else
      hPenOld = SelectObject(lHDC, hPenLight)
   End If
   MoveToEx lHDC, tBR.Left, tBR.bottom - 1, tJunk
   LineTo lHDC, tBR.Left, tBR.Top
   LineTo lHDC, tBR.right - 1, tBR.Top
   SelectObject lHDC, hPenOld
   If (bPressed) Then
      hPenOld = SelectObject(lHDC, hPenLight)
   Else
      hPenOld = SelectObject(lHDC, hPenShadow)
   End If
   MoveToEx lHDC, tBR.right - 1, tBR.Top + 1, tJunk
   LineTo lHDC, tBR.right - 1, tBR.bottom - 1
   LineTo lHDC, tBR.Left - 1, tBR.bottom - 1
   SelectObject lHDC, hPenOld
   
   DeleteObject hPenLight
   DeleteObject hPenShadow
   
   ' Draw the glyph:
   Dim sFnt As New StdFont
   Dim sGlyph As String
   sFnt.Name = "Marlett"
   sFnt.Size = m_fnt.Size + 2
   Dim iFnt As IFont
   Set iFnt = sFnt
   
   hFontOld = SelectObject(lHDC, iFnt.hFont)
   If (bPressed) Then
      OffsetRect tBR, 1, 1
   End If
   If (bEnabled) Then
      SetTextColor lHDC, TranslateColor(m_oForeColor)
   Else
      SetTextColor lHDC, GetSysColor(vbButtonShadow And &amp;H1F&amp;)
   End If
   If (iButton = 1) Then
      sGlyph = "t"
   Else
      sGlyph = "u"
   End If
   If (m_bIsNT) Then
      DrawTextW lHDC, StrPtr(sGlyph), -1, tBR, DT_SINGLELINE Or DT_CENTER Or
       DT_VCENTER Or DT_WORD_ELLIPSIS
   Else
      DrawText lHDC, sGlyph, -1, tBR, DT_SINGLELINE Or DT_CENTER Or DT_VCENTER
       Or DT_WORD_ELLIPSIS
   End If
   SelectObject lHDC, hFontOld
   
End Sub

Private Sub pEraseClientTrack()
Dim i As Long
Dim j As Long
   For i = 1 To m_iBarCount
      For j = 1 To m_tBar(i).lItemCount
         m_tBar(i).tItem(j).bTrack = False
      Next j
   Next i
End Sub

Private Function TranslateColor(ByVal oClr As OLE_COLOR, _
                        Optional hPal As Long = 0) As Long
    ' Convert Automation color to Windows color
    If OleTranslateColor(oClr, hPal, TranslateColor) Then
        TranslateColor = CLR_INVALID
    End If
End Function
Private Property Get SlightlyLighterColour(ByVal oColor As OLE_COLOR) As Long
Dim lC As Long
Dim h As Single, s As Single, l As Single
Dim lR As Long, lG As Long, lB As Long
Static s_lColLast As Long
Static s_lLightColLast As Long
   
   lC = TranslateColor(oColor)
   If (lC &lt;&gt; s_lColLast) Then
      s_lColLast = lC
      RGBToHLS lC And &amp;HFF&amp;, (lC \ &amp;H100) And &amp;HFF&amp;, (lC \ &amp;H10000) And &amp;HFF&amp;,
       h, s, l
      If (l &gt; 0.99) Then
         l = l * 0.9
      Else
         'Debug.Print l
         l = l + (1# - l) * 0.6
         If (s &gt; 0.1) Then
            s = s + (1# - s) * 0.6
         End If
      End If
      HLSToRGB h, s, l, lR, lG, lB
      s_lLightColLast = RGB(lR, lG, lB)
   End If
   SlightlyLighterColour = s_lLightColLast
End Property
Private Property Get DarkerColour(ByVal oColor As OLE_COLOR) As Long
Dim lC As Long
Dim h As Single, s As Single, l As Single
Dim lR As Long, lG As Long, lB As Long
Static s_lColLast As Long
Static s_lDarkColLast As Long
   
   lC = TranslateColor(oColor)
   If (lC &lt;&gt; s_lColLast) Then
      s_lColLast = lC
      RGBToHLS lC And &amp;HFF&amp;, (lC \ &amp;H100) And &amp;HFF&amp;, (lC \ &amp;H10000) And &amp;HFF&amp;,
       h, s, l
      If (l &lt; 0.1) Then
         l = l * 1.5
      Else
         'Debug.Print l
         l = l + (l - 1#) * 0.6
         s = s + (s - 1#) * 0.6
      End If
      HLSToRGB h, s, l, lR, lG, lB
      s_lDarkColLast = RGB(lR, lG, lB)
   End If
   DarkerColour = s_lDarkColLast
End Property

Private Sub RGBToHLS( _
     ByVal r As Long, ByVal g As Long, ByVal b As Long, _
     h As Single, s As Single, l As Single _
     )
 Dim Max As Single
 Dim Min As Single
 Dim delta As Single
 Dim rR As Single, rG As Single, rB As Single

     rR = r / 255: rG = g / 255: rB = b / 255

 '{Given: rgb each in [0,1].
 ' Desired: h in [0,360] and s in [0,1], except if s=0, then h=UNDEFINED.}
         Max = Maximum(rR, rG, rB)
         Min = Minimum(rR, rG, rB)
             l = (Max + Min) / 2 '{This is the lightness}
         '{Next calculate saturation}
         If Max = Min Then
             'begin {Acrhomatic case}
             s = 0
             h = 0
             'end {Acrhomatic case}
         Else
             'begin {Chromatic case}
                 '{First calculate the saturation.}
             If l &lt;= 0.5 Then
                 s = (Max - Min) / (Max + Min)
             Else
                 s = (Max - Min) / (2 - Max - Min)
             End If
             '{Next calculate the hue.}
             delta = Max - Min
             If rR = Max Then
                     h = (rG - rB) / delta '{Resulting color is between yellow
                      and magenta}
             ElseIf rG = Max Then
                 h = 2 + (rB - rR) / delta '{Resulting color is between cyan
                  and yellow}
             ElseIf rB = Max Then
                 h = 4 + (rR - rG) / delta '{Resulting color is between magenta
                  and cyan}
             End If
         'end {Chromatic Case}
     End If
 End Sub

Private Sub HLSToRGB( _
     ByVal h As Single, ByVal s As Single, ByVal l As Single, _
     r As Long, g As Long, b As Long _
     )
Dim rR As Single, rG As Single, rB As Single
Dim Min As Single, Max As Single

     If s = 0 Then
     ' Achromatic case:
     rR = l: rG = l: rB = l
     Else
     ' Chromatic case:
     ' delta = Max-Min
     If l &lt;= 0.5 Then
         's = (Max - Min) / (Max + Min)
         ' Get Min value:
         Min = l * (1 - s)
     Else
         's = (Max - Min) / (2 - Max - Min)
         ' Get Min value:
         Min = l - s * (1 - l)
     End If
     ' Get the Max value:
     Max = 2 * l - Min
     
     ' Now depending on sector we can evaluate the h,l,s:
     If (h &lt; 1) Then
         rR = Max
         If (h &lt; 0) Then
             rG = Min
             rB = rG - h * (Max - Min)
         Else
             rB = Min
             rG = h * (Max - Min) + rB
         End If
     ElseIf (h &lt; 3) Then
         rG = Max
         If (h &lt; 2) Then
             rB = Min
             rR = rB - (h - 2) * (Max - Min)
         Else
             rR = Min
             rB = (h - 2) * (Max - Min) + rR
         End If
     Else
         rB = Max
         If (h &lt; 4) Then
             rR = Min
             rG = rR - (h - 4) * (Max - Min)
         Else
             rG = Min
             rR = (h - 4) * (Max - Min) + rG
         End If
         
     End If
             
     End If
     r = rR * 255: g = rG * 255: b = rB * 255
 End Sub
 Private Function Maximum(rR As Single, rG As Single, rB As Single) As Single
   If (rR &gt; rG) Then
      If (rR &gt; rB) Then
         Maximum = rR
      Else
         Maximum = rB
      End If
   Else
      If (rB &gt; rG) Then
         Maximum = rB
      Else
         Maximum = rG
      End If
   End If
End Function
Private Function Minimum(rR As Single, rG As Single, rB As Single) As Single
   If (rR &lt; rG) Then
      If (rR &lt; rB) Then
         Minimum = rR
      Else
         Minimum = rB
      End If
   Else
      If (rB &lt; rG) Then
         Minimum = rB
      Else
         Minimum = rG
      End If
   End If
End Function

Private Sub ImageListDrawIcon( _
        ByVal ptrVb6ImageList As Long, _
        ByVal hdc As Long, _
        ByVal hIml As Long, _
        ByVal iIconIndex As Long, _
        ByVal lX As Long, _
        ByVal lY As Long, _
        Optional ByVal bSelected As Boolean = False, _
        Optional ByVal bBlend25 As Boolean = False _
    )
Dim lFlags As Long
Dim lR As Long

   lFlags = ILD_TRANSPARENT
   If (bSelected) Then
      lFlags = lFlags Or ILD_SELECTED
   End If
   If (bBlend25) Then
      lFlags = lFlags Or ILD_BLEND25
   End If
   If (ptrVb6ImageList &lt;&gt; 0) Then
      Dim o As Object
      On Error Resume Next
      Set o = ObjectFromPtr(ptrVb6ImageList)
      If Not (o Is Nothing) Then
         If ((lFlags And ILD_SELECTED) = ILD_SELECTED) Then
            lFlags = 2 ' best we can do with VB6 Image List
         End If
         o.ListImages(iIconIndex + 1).draw hdc, lX * Screen.TwipsPerPixelX, lY
          * Screen.TwipsPerPixelY, lFlags
      End If
      On Error GoTo 0
   Else
      lR = ImageList_Draw( _
                hIml, _
                iIconIndex, _
                hdc, _
                lX, _
                lY, _
                lFlags)
      If (lR = 0) Then
         'Debug.Print "Failed to draw Image: " &amp; iIconIndex &amp; " onto hDC " &amp;
          hdc, "ImageListDrawIcon"
      End If
   End If
   
End Sub
Private Sub ImageListDrawIconDisabled( _
        ByVal ptrVb6ImageList As Long, _
        ByVal hdc As Long, _
        ByVal hIml As Long, _
        ByVal iIconIndex As Long, _
        ByVal lX As Long, _
        ByVal lY As Long, _
        ByVal lSize As Long, _
        Optional ByVal asShadow As Boolean _
    )
Dim lR As Long
Dim hIcon As Long

   hIcon = 0
   If (ptrVb6ImageList &lt;&gt; 0) Then
      Dim o As Object
      On Error Resume Next
      Set o = ObjectFromPtr(ptrVb6ImageList)
      If Not (o Is Nothing) Then
          hIcon = o.ListImages(iIconIndex + 1).ExtractIcon()
      End If
      On Error GoTo 0
   Else
      hIcon = ImageList_GetIcon(hIml, iIconIndex, 0)
   End If
   If (hIcon &lt;&gt; 0) Then
      If (asShadow) Then
         Dim hBr As Long
         hBr = GetSysColorBrush(vb3DShadow And &amp;H1F)
         lR = DrawState(hdc, hBr, 0, hIcon, 0, lX, lY, lSize, lSize, DST_ICON
          Or DSS_MONO)
         DeleteObject hBr
      Else
         lR = DrawState(hdc, 0, 0, hIcon, 0, lX, lY, lSize, lSize, DST_ICON Or
          DSS_DISABLED)
      End If
      DestroyIcon hIcon
   End If
   
End Sub
Private Property Get ObjectFromPtr(ByVal lPtr As Long) As Object
Dim oTemp As Object
   ' Turn the pointer into an illegal, uncounted interface
   CopyMemory oTemp, lPtr, 4
   ' Do NOT hit the End button here! You will crash!
   ' Assign to legal reference
   Set ObjectFromPtr = oTemp
   ' Still do NOT hit the End button here! You will still crash!
   ' Destroy the illegal reference
   CopyMemory oTemp, 0&amp;, 4
   ' OK, hit the End button if you must--you'll probably still crash,
   ' but it will be because of the subclass, not the uncounted reference
End Property

Private Sub Scroll()
   
   If (m_iBarCount &gt; 0) And (m_iSelBar &gt; 0) Then
      If (m_tBar(m_iSelBar).bDownScrollDown And
       m_tBar(m_iSelBar).bTrackScrollDown) Then
         ' scroll down
         If ((m_tBar(m_iSelBar).lSize + m_tBar(m_iSelBar).lOffset) &gt; _
            (m_tBar(m_iSelBar).tClientR.bottom -
             m_tBar(m_iSelBar).tClientR.Top)) Then
            m_tBar(m_iSelBar).lOffset = m_tBar(m_iSelBar).lOffset -
             m_lItemHeight
            pDraw
         End If
      ElseIf (m_tBar(m_iSelBar).bDownScrollUp And
       m_tBar(m_iSelBar).bTrackScrollUp) Then
         ' scroll up
         If (m_tBar(m_iSelBar).lOffset &lt; 0) Then
            m_tBar(m_iSelBar).lOffset = m_tBar(m_iSelBar).lOffset +
             m_lItemHeight
            If (m_tBar(m_iSelBar).lOffset &gt; 0) Then
               m_tBar(m_iSelBar).lOffset = 0
            End If
            pDraw
         End If
      End If
      
   Else
      m_tmr.Enabled = False
   End If

End Sub

Private Sub pScrollIntoView(ByVal lItemIndex As Long)
Dim lMoveYDown As Long
Dim lMoveYUp As Long
Dim i As Long
Dim lRem As Long
Dim lIncr As Long
Dim lInitialOff As Long

   lMoveYDown = (m_tBar(m_iSelBar).tItem(lItemIndex).tR.bottom +
    m_tBar(m_iSelBar).lOffset - m_tBar(m_iSelBar).tClientR.bottom)
   lMoveYUp = m_tBar(m_iSelBar).tClientR.Top -
    (m_tBar(m_iSelBar).tItem(lItemIndex).tR.Top + m_tBar(m_iSelBar).lOffset)
   
   If (lMoveYDown &lt; 0) And (lMoveYUp &lt; 0) Then
      ' control too small or nowhere to move
      pDraw
   ElseIf (lMoveYDown &gt; 0) Then
      lIncr = 4
      i = 0
      lInitialOff = m_tBar(m_iSelBar).lOffset
      Do
         m_tBar(m_iSelBar).lOffset = m_tBar(m_iSelBar).lOffset - lIncr
         pDraw
         lIncr = lIncr + 1
         i = i + lIncr
         If (i &gt; lMoveYDown) Then
            m_tBar(m_iSelBar).lOffset = lInitialOff - lMoveYDown
            Exit Do
         End If
      Loop While (i &lt; lMoveYDown)
      If Not (m_tBar(m_iSelBar).lOffset Mod (m_lItemHeight) = 0) Then
         m_tBar(m_iSelBar).lOffset = m_tBar(m_iSelBar).lOffset -
          (m_tBar(m_iSelBar).lOffset Mod (m_lItemHeight)) - m_lItemHeight
      End If
      pDraw
   ElseIf (lMoveYUp &gt; 0) Then
      lInitialOff = m_tBar(m_iSelBar).lOffset
      lIncr = 4
      i = 0
      Do
         m_tBar(m_iSelBar).lOffset = m_tBar(m_iSelBar).lOffset + lIncr
         pDraw
         lIncr = lIncr + 1
         i = i + lIncr
         If (m_tBar(m_iSelBar).lOffset &gt; 0) Then
            m_tBar(m_iSelBar).lOffset = 0
            Exit Do
         ElseIf (i &gt; lMoveYUp) Then
            m_tBar(m_iSelBar).lOffset = lInitialOff + lMoveYUp
            Exit Do
         Else
            pDraw
         End If
      Loop While (i &lt; lMoveYUp)
      If Not (m_tBar(m_iSelBar).lOffset Mod (m_lItemHeight) = 0) Then
         m_tBar(m_iSelBar).lOffset = m_tBar(m_iSelBar).lOffset -
          (m_tBar(m_iSelBar).lOffset Mod (m_lItemHeight)) - m_lItemHeight
      End If
      pDraw
   Else
      pDraw
   End If


End Sub

Private Sub pScrollSelect(ByVal lNewBarIndex As Long)
   '
   
   If (m_iSelBar &gt; 0) And (m_iBarCount &gt; 0) Then
      
      ' Get a copy of the control surface:
      Dim cMemDC As New pcMemDC
      Dim tR As RECT
      GetClientRect m_hWnd, tR
      cMemDC.Width = tR.right - tR.Left
      cMemDC.Height = tR.bottom - tR.Top
      BitBlt cMemDC.hdc, 0, 0, tR.right - tR.Left, tR.bottom - tR.Top,
       m_cMemDC.hdc, 0, 0, vbSrcCopy
      
      
      Dim lScrollTop As Long
      Dim lScrollBottom As Long
      Dim lOffset As Long
      Dim lY As Long
      Dim hFontOld As Long
      Dim hBr As Long
      Dim lIncr As Long
      Dim lSrcY As Long
      Dim tFillR As RECT
      
      ' Now which way are we scrolling?
      If (lNewBarIndex &lt; m_iSelBar) Then
         
         ' scrolling down:
         ' The area to scroll is from the bottom of the new bar index
         ' to the bottom of the visible client area:
         lScrollTop = m_tBar(lNewBarIndex).tCaptionR.bottom
         lScrollBottom = m_tBar(m_iSelBar).tClientR.bottom
         lOffset = m_tBar(m_iSelBar).tCaptionR.bottom - lScrollTop
         m_iSelBar = lNewBarIndex
         
         hFontOld = SelectObject(m_cMemDC.hdc, m_fnt.hFont)
         hBr = CreateSolidBrush(TranslateColor(m_oBackColor))
         
         lY = lScrollTop
         lIncr = 4
         Do
            ' Draw the area of the bar being exposed:
            FillRect m_cMemDC.hdc, m_tBar(m_iSelBar).tClientR, hBr
            pDrawClient m_cMemDC.hdc
            ' Draw the bit we're scrolling:
            BitBlt m_cMemDC.hdc, 0, lY, tR.right - tR.Left, lScrollBottom - lY,
             cMemDC.hdc, 0, lScrollTop, vbSrcCopy
            ' Swap to control:
            BitBlt UserControl.hdc, 0, 0, tR.right - tR.Left, lScrollBottom,
             m_cMemDC.hdc, 0, 0, vbSrcCopy
            ' Increment y:
            lY = lY + lIncr
            ' Get faster:
            lIncr = lIncr + 1
         Loop While lY &lt; (lScrollBottom - lOffset)
         
         DeleteObject hBr
         SelectObject m_cMemDC.hdc, hFontOld
         
      Else
         
         ' scrolling up:
         ' The area to scroll is from the bottom of the new bar index
         ' to the top of the selected bar visible client area:
         lScrollTop = m_tBar(m_iSelBar).tClientR.Top
         lScrollBottom = m_tBar(lNewBarIndex).tCaptionR.bottom
         lOffset = lScrollBottom - m_tBar(m_iSelBar).tClientR.bottom
         
         hFontOld = SelectObject(m_cMemDC.hdc, m_fnt.hFont)
         hBr = CreateSolidBrush(TranslateColor(m_oBackColor))
         
         lY = lScrollBottom
         lSrcY = lScrollTop
         lIncr = 4
         LSet tFillR = tR
         Do
            ' Draw the client area of the bar being exposed:
            tFillR.Top = 0
            tFillR.bottom = lScrollBottom
            FillRect m_cMemDC.hdc, tFillR, hBr
            pDrawClient m_cMemDC.hdc
            ' Draw the bit we're scrolling:
            BitBlt m_cMemDC.hdc, 0, lScrollTop, tR.right - tR.Left, lY -
             lScrollTop, cMemDC.hdc, 0, lSrcY, vbSrcCopy
            ' Swap to control:
            BitBlt UserControl.hdc, 0, lScrollTop, tR.right - tR.Left,
             lScrollBottom - lScrollTop, m_cMemDC.hdc, 0, lScrollTop, vbSrcCopy
            ' Decrement y:
            lY = lY - lIncr
            lSrcY = lSrcY + lIncr
            ' Get faster:
            lIncr = lIncr + 1
         Loop While (lY &gt; lScrollTop + lOffset)
         
         DeleteObject hBr
         SelectObject m_cMemDC.hdc, hFontOld
         
      End If
      
   End If
   
   '
End Sub

Private Sub pSetToolTipText(ByVal sText As String)
   On Error Resume Next
   'UserControl.Extender.ToolTipText = sText
   On Error GoTo 0
End Sub

Private Sub pInitialise()
   m_hWnd = UserControl.hWnd
   Set m_cMemDC = New pcMemDC
   Set m_fnt = UserControl.Font
   m_bRunTime = UserControl.Ambient.UserMode
   
   If Not m_bRunTime Then
      Dim cBar As cToolBoxBar
      Dim i As Long
      Set cBar = Bars.Add("S1", , "Sample Bar 1")
      For i = 1 To 5
         cBar.Items.Add "S" &amp; i, , "Sample Item " &amp; i
      Next i
      Bars.Add "S2", , "Sample Bar 2"
   End If
   
End Sub

Private Sub m_tmr_Timer()
   '
   If (timeGetTime() - m_lClickTime &gt; 300) Then
      Scroll
   End If
   If (m_iSelBar &gt; 0) Then
      If Not (m_bClickBar Or m_bClickScroll) Then
         Dim tP As POINTAPI
         GetCursorPos tP
         ScreenToClient m_hWnd, tP
         If PtInRect(m_tBar(m_iSelBar).tClientR, tP.x, tP.y) = 0 Then
            UserControl_MouseMove 0, 0, -15, -15
         End If
      End If
   End If
   '
End Sub

Private Sub UserControl_DblClick()
   
   '
   Dim tP As POINTAPI
   GetCursorPos tP
   ScreenToClient m_hWnd, tP
   Dim tWR As RECT
   GetClientRect m_hWnd, tWR
   
   Dim i As Long
   Dim j As Long
   Dim tR As RECT
   Dim x As Single
   Dim y As Single
   
   x = ScaleX(tP.x, vbPixels, UserControl.ScaleMode)
   y = ScaleY(tP.y, vbPixels, UserControl.ScaleMode)
   
   For i = 1 To m_iBarCount
      LSet tR = m_tBar(i).tCaptionR
      tR.right = tWR.right ' no double clicking in scroll buttons
      If Not (PtInRect(tR, tP.x, tP.y) = 0) Then
         Dim cT As New cToolBoxBar
         cT.fInit ObjPtr(Me), m_hWnd, m_tBar(i).lId
         RaiseEvent BarDblClick(cT, vbLeftButton, 0, x, y)
         Exit Sub
      End If
   Next i
   
   For j = 1 To m_tBar(m_iSelBar).lItemCount
      LSet tR = m_tBar(m_iSelBar).tItem(j).tR
      OffsetRect tR, 0, m_tBar(m_iSelBar).lOffset
      If Not (PtInRect(tR, tP.x, tP.y) = 0) Then
         If (m_tBar(m_iSelBar).tItem(j).bSelected) Then
            Dim cTI As New cToolItem
            cTI.fInit ObjPtr(Me), m_hWnd, m_tBar(m_iSelBar).lId,
             m_tBar(m_iSelBar).tItem(j).lId
            RaiseEvent ItemDblClick(cTI, vbLeftButton, 0, x, y)
         End If
         Exit Sub
      End If
   Next j
   '
   
End Sub

Private Sub UserControl_Initialize()
   '
   'Debug.Print "vbalToolBoxBarCtl:Initialise", ObjPtr(Me)
   
   m_lCaptionHeight = 20
   m_lIconWidth = 16
   m_lIconHeight = 16
   m_oBackColor = vbButtonFace
   m_oForeColor = vbWindowText
   
   Dim lVer As Long
   lVer = GetVersion()
   m_bIsNT = ((lVer And &amp;H80000000) = 0)
   '
End Sub

Private Sub UserControl_InitProperties()
   
   pInitialise
   
End Sub

Private Sub UserControl_KeyDown(KeyCode As Integer, Shift As Integer)
   '
   If Not (m_bRunTime) Then
      Exit Sub
   End If
   
   RaiseEvent KeyDown(KeyCode, Shift)
   
   If (m_iBarCount &gt; 0) And (m_iSelBar &gt; 0) Then
      Dim j As Long
      Dim lFirstIndex As Long
      Dim lLastIndex As Long
      Dim lSelIndex As Long
      Dim lNewIndex As Long
      Dim cT As New cToolItem
   
      Select Case KeyCode
      Case vbKeyDown
         '
         ' move to next selected item:
         For j = 1 To m_tBar(m_iSelBar).lItemCount - 1
            If (m_tBar(m_iSelBar).tItem(j).bSelected) Then
               m_tBar(m_iSelBar).tItem(j).bSelected = False
               m_tBar(m_iSelBar).tItem(j + 1).bSelected = True
               pScrollIntoView j + 1
               cT.fInit ObjPtr(Me), m_hWnd, m_tBar(m_iSelBar).lId,
                m_tBar(m_iSelBar).tItem(j + 1).lId
               RaiseEvent ItemSelected(cT)
               Exit For
            End If
         Next j
         
         '
      Case vbKeyUp
         '
         ' move to next selected item:
         For j = 2 To m_tBar(m_iSelBar).lItemCount
            If (m_tBar(m_iSelBar).tItem(j).bSelected) Then
               m_tBar(m_iSelBar).tItem(j).bSelected = False
               m_tBar(m_iSelBar).tItem(j - 1).bSelected = True
               pScrollIntoView j - 1
               cT.fInit ObjPtr(Me), m_hWnd, m_tBar(m_iSelBar).lId,
                m_tBar(m_iSelBar).tItem(j - 1).lId
               RaiseEvent ItemSelected(cT)
               Exit For
            End If
         Next j
         
         '
         
      Case vbKeyPageUp
         '
         ' find the gap between partially hidden items:
         For j = 1 To m_tBar(m_iSelBar).lItemCount
            If (m_tBar(m_iSelBar).tItem(j).bSelected) Then
               lSelIndex = j
            End If
         Next j
         lNewIndex = lSelIndex - ((m_tBar(m_iSelBar).tClientR.bottom -
          m_tBar(m_iSelBar).tClientR.Top) \ m_lItemHeight)
         If (lNewIndex &lt; 1) Then
            lNewIndex = 1
         End If
         If Not (lSelIndex = lNewIndex) Then
            m_tBar(m_iSelBar).tItem(lSelIndex).bSelected = False
            m_tBar(m_iSelBar).tItem(lNewIndex).bSelected = True
            pScrollIntoView lNewIndex
            cT.fInit ObjPtr(Me), m_hWnd, m_tBar(m_iSelBar).lId,
             m_tBar(m_iSelBar).tItem(lNewIndex).lId
            RaiseEvent ItemSelected(cT)
         End If
         '
         
      Case vbKeyPageDown
         '
         ' find the gap between partially hidden items:
         For j = 1 To m_tBar(m_iSelBar).lItemCount
            If (m_tBar(m_iSelBar).tItem(j).bSelected) Then
               lSelIndex = j
            End If
         Next j
         lNewIndex = lSelIndex + ((m_tBar(m_iSelBar).tClientR.bottom -
          m_tBar(m_iSelBar).tClientR.Top) \ m_lItemHeight)
         If (lNewIndex &gt; m_tBar(m_iSelBar).lItemCount) Or (lNewIndex &lt; 1) Then
            lNewIndex = m_tBar(m_iSelBar).lItemCount
         End If
         If Not (lSelIndex = lNewIndex) Then
            m_tBar(m_iSelBar).tItem(lSelIndex).bSelected = False
            m_tBar(m_iSelBar).tItem(lNewIndex).bSelected = True
            pScrollIntoView lNewIndex
            cT.fInit ObjPtr(Me), m_hWnd, m_tBar(m_iSelBar).lId,
             m_tBar(m_iSelBar).tItem(lNewIndex).lId
            RaiseEvent ItemSelected(cT)

         End If
         '
      
      Case vbKeyHome
         '
         If (m_tBar(m_iSelBar).lItemCount &gt; 0) Then
            If Not m_tBar(m_iSelBar).tItem(1).bSelected Then
               For j = 1 To m_tBar(m_iSelBar).lItemCount
                  m_tBar(m_iSelBar).tItem(j).bSelected = False
               Next j
               m_tBar(m_iSelBar).tItem(1).bSelected = True
               pScrollIntoView 1
               cT.fInit ObjPtr(Me), m_hWnd, m_tBar(m_iSelBar).lId,
                m_tBar(m_iSelBar).tItem(1).lId
               RaiseEvent ItemSelected(cT)
            End If
         End If
         '
         
      Case vbKeyEnd
         '
         If (m_tBar(m_iSelBar).lItemCount &gt; 0) Then
            If Not
             (m_tBar(m_iSelBar).tItem(m_tBar(m_iSelBar).lItemCount).bSelected)
             Then
               For j = 1 To m_tBar(m_iSelBar).lItemCount
                  m_tBar(m_iSelBar).tItem(j).bSelected = False
               Next j
               m_tBar(m_iSelBar).tItem(m_tBar(m_iSelBar).lItemCount).bSelected
                = True
               pScrollIntoView m_tBar(m_iSelBar).lItemCount
               cT.fInit ObjPtr(Me), m_hWnd, m_tBar(m_iSelBar).lId,
                m_tBar(m_iSelBar).tItem(m_tBar(m_iSelBar).lItemCount).lId
               RaiseEvent ItemSelected(cT)

            End If
         End If
         '
         
      End Select
   End If
   '
End Sub

Private Sub UserControl_KeyPress(KeyAscii As Integer)
   '
   RaiseEvent KeyPress(KeyAscii)
   '
End Sub

Private Sub UserControl_KeyUp(KeyCode As Integer, Shift As Integer)
   '
   RaiseEvent KeyUp(KeyCode, Shift)
   '
End Sub

Private Sub UserControl_MouseDown(Button As Integer, Shift As Integer, x As
 Single, y As Single)
   '
   If Not m_bRunTime Then
      Exit Sub
   End If
   
   ' check all of the bars and scroll buttons:
   Dim tP As POINTAPI
   GetCursorPos tP
   ScreenToClient m_hWnd, tP
   LSet m_tDownP = tP
   
   Dim i As Long
   Dim j As Long
   Dim bDone As Boolean
      
   For i = 1 To m_iBarCount
      If (Button = vbLeftButton) Then
         If Not (PtInRect(m_tBar(i).tCaptionR, tP.x, tP.y) = 0) Then
            m_bClickBar = True
            m_tBar(i).bDown = True
            m_tBar(i).bTrack = True
            bDone = True
            pEraseClientTrack
            pDraw
         End If
      End If
   Next i
   
   If bDone Then
      Exit Sub
   End If
   
   If (m_iBarCount &gt; 0) And (m_iSelBar &gt; 0) Then
      i = m_iSelBar
      If Not (PtInRect(m_tBar(i).tScrollDownR, tP.x, tP.y) = 0) Then
         m_bClickScroll = True
         pEraseClientTrack
         m_tBar(i).bDownScrollDown = True
         m_tBar(i).bTrackScrollDown = True
         Scroll
         m_lClickTime = timeGetTime()
         m_tmr.Enabled = True
      ElseIf Not (PtInRect(m_tBar(i).tScrollUpR, tP.x, tP.y) = 0) Then
         m_bClickScroll = True
         pEraseClientTrack
         m_tBar(i).bDownScrollUp = True
         m_tBar(i).bTrackScrollUp = True
         Scroll
         m_lClickTime = timeGetTime()
         m_tmr.Enabled = True
      Else
         If Not m_bClickBar Then
            For j = 1 To m_tBar(i).lItemCount
               Dim tItemR As RECT
               LSet tItemR = m_tBar(i).tItem(j).tR
               OffsetRect tItemR, 0, m_tBar(i).lOffset
               If Not (PtInRect(tItemR, tP.x, tP.y) = 0) Then
                  pEraseClientTrack
                  m_tBar(i).tItem(j).bTrack = True
                  m_tBar(i).tItem(j).bDown = True
                  fItemSelected(m_tBar(i).lId, m_tBar(i).tItem(j).lId) = True
                  pDraw
                  Dim cT As New cToolItem
                  cT.fInit ObjPtr(Me), m_hWnd, m_tBar(i).lId,
                   m_tBar(i).tItem(j).lId
                  RaiseEvent ItemSelected(cT)
                  Exit For
               End If
            Next j
         End If
      End If
   End If
      
   '
End Sub

Private Sub UserControl_MouseMove(Button As Integer, Shift As Integer, x As
 Single, y As Single)
   '
   If Not m_bRunTime Then
      Exit Sub
   End If
   
   
   Dim tP As POINTAPI
   GetCursorPos tP
   ScreenToClient m_hWnd, tP
   
   Dim i As Long
   Dim j As Long
   
   If (m_iDragBar &gt; 0) And (m_iDragItem = 0) Then
      ' in bar dragging mode
      For i = 1 To m_iBarCount
         If Not (i = m_iDragBar) Then
            If Not (PtInRect(m_tBar(i).tCaptionR, tP.x, tP.y) = 0) Then
               If (i &gt; m_iDragBar) Then
                  If (tP.y &lt; m_tBar(i).tCaptionR.Top + m_lCaptionHeight \ 2)
                   Then
                     Exit Sub
                  End If
               End If
               ' swap m_iDragBar with i, set m_iDragBar to i, return
               Dim tSwap As tBar
               LSet tSwap = m_tBar(i)
               LSet m_tBar(i) = m_tBar(m_iDragBar)
               LSet m_tBar(m_iDragBar) = tSwap
               If (m_iDragBar = m_iSelBar) Then
                  m_iSelBar = i
               ElseIf (i = m_iSelBar) Then
                  m_iSelBar = m_iDragBar
               End If
               m_iDragBar = i
               pResize
               Exit Sub
            End If
         End If
      Next i
      
      Dim tR As RECT
      GetClientRect m_hWnd, tR
      If (PtInRect(tR, tP.x, tP.y) = 0) Then
         Screen.MousePointer = vbNoDrop
      Else
         Screen.MousePointer = vbSizeNS
      End If
      
   Else
   
      For i = 1 To m_iBarCount
         
         If (m_tBar(i).bDown) Then
            If Abs(m_tDownP.x - tP.x) &gt; 4 Or Abs(m_tDownP.y - tP.y) &gt; 4 Then
               If (PtInRect(m_tBar(i).tCaptionR, tP.x, tP.y) = 0) Then
                  Screen.MousePointer = vbSizeNS
                  m_iDragItem = 0
                  m_iDragBar = i
                  pEraseClientTrack
                  pDraw
                  Exit Sub
               End If
            Else
               
               If (PtInRect(m_tBar(i).tCaptionR, tP.x, tP.y) = 0) Then
                  If (m_tBar(i).bTrack) Then
                     m_tBar(i).bTrack = False
                     pEraseClientTrack
                     pDraw
                     Exit Sub
                  End If
               Else
                  If Not (m_tBar(i).bTrack) Then
                     m_tBar(i).bTrack = True
                     pSetToolTipText m_tBar(i).sCaption
                     pEraseClientTrack
                     pDraw
                     Exit Sub
                  End If
               End If
            End If
            
         Else
            If (PtInRect(m_tBar(i).tScrollDownR, tP.x, tP.y) = 0) Then
               If (m_tBar(i).bTrackScrollDown) Then
                  m_tBar(i).bTrackScrollDown = False
                  pDraw
               End If
            Else
                If Not (m_tBar(i).bTrackScrollDown) Then
                  m_tBar(i).bTrackScrollDown = True
                  pEraseClientTrack
                  pDraw
               End If
            End If
            
            If (PtInRect(m_tBar(i).tScrollUpR, tP.x, tP.y) = 0) Then
               If (m_tBar(i).bTrackScrollUp) Then
                  m_tBar(i).bTrackScrollUp = False
                  pDraw
               End If
            Else
                If Not (m_tBar(i).bTrackScrollDown) Then
                  m_tBar(i).bTrackScrollDown = True
                  pEraseClientTrack
                  pDraw
               End If
            End If
                  
            ' check the client area:
            If Not (m_bClickBar Or m_bClickScroll) Then
               If (i = m_iSelBar) Then
                  For j = 1 To m_tBar(i).lItemCount
                     Dim tItemR As RECT
                     LSet tItemR = m_tBar(i).tItem(j).tR
                     OffsetRect tItemR, 0, m_tBar(i).lOffset
                     If (PtInRect(tItemR, tP.x, tP.y) = 0) Then
                        If (m_tBar(i).tItem(j).bTrack) Then
                           m_tBar(i).tItem(j).bTrack = False
                           pDraw
                        End If
                     Else
                        If Not (m_tBar(i).tItem(j).bTrack) Then
                           pEraseClientTrack
                           m_tBar(i).tItem(j).bTrack = True
                           m_tmr.Enabled = True
                           pDraw
                        Else
                           If (m_tBar(i).tItem(j).bDown) Then
                              If Abs(m_tDownP.x - tP.x) &gt; 4 Or Abs(m_tDownP.y -
                               tP.y) &gt; 4 Then
                                 If (m_tBar(i).tItem(j).bCanDrag) Then
                                    m_tBar(i).tItem(j).bDown = False
                                    m_iDragItem = j
                                    UserControl.OLEDrag
                                 End If
                              End If
                           End If
                        End If
                     End If
                  Next j
               End If
            End If
            
         End If
         
      Next i
               
   End If
   
   '
End Sub

Private Sub UserControl_MouseUp(Button As Integer, Shift As Integer, x As
 Single, y As Single)
   '
   If Not m_bRunTime Then
      Exit Sub
   End If
   
   
   m_bClickBar = False
   m_bClickScroll = False
   m_tmr.Enabled = False
      
   Dim tP As POINTAPI
   GetCursorPos tP
   ScreenToClient m_hWnd, tP
   
   Dim i As Long
   Dim j As Long
   Dim cTI As cToolItem
   Dim cT As cToolBoxBar
   
   If (m_iDragBar &gt; 0) Then
      m_iDragBar = 0
      For i = 1 To m_iBarCount
         m_tBar(i).bDown = False
         m_tBar(i).bTrack = False
      Next i
   Else
      For i = 1 To m_iBarCount
         If Not (PtInRect(m_tBar(i).tCaptionR, tP.x, tP.y) = 0) Then
            Set cT = New cToolBoxBar
            cT.fInit ObjPtr(Me), m_hWnd, m_tBar(i).lId
            If (m_tBar(i).bDown And m_tBar(i).bTrack) Then
               fBarSelected(m_tBar(i).lId) = True
               RaiseEvent BarSelected(cT)
            End If
         End If
         m_tBar(i).bDown = False
         m_tBar(i).bTrack = False
         m_tBar(i).bDownScrollDown = False
         m_tBar(i).bDownScrollUp = False
         m_tBar(i).bTrackScrollDown = False
         m_tBar(i).bTrackScrollUp = False
         For j = 1 To m_tBar(i).lItemCount
            If ((i = m_iSelBar) And (m_tBar(i).tItem(j).bDown) And
             (m_tBar(i).tItem(j).bSelected)) Then
               Set cTI = New cToolItem
               cTI.fInit ObjPtr(Me), m_hWnd, m_tBar(i).lId,
                m_tBar(i).tItem(j).lId
            End If
            m_tBar(i).tItem(j).bDown = False
            m_tBar(i).tItem(j).bTrack = False
         Next j
      Next i
      
      If Not (cT Is Nothing) Then
         If (Button = vbRightButton) Then
            m_iDragBar = cT.Index
            pDraw
            RaiseEvent BarClick(cT, Button, Shift, x, y)
            m_iDragBar = 0
            pDraw
         End If
      Else
         RaiseEvent ItemClick(cTI, Button, Shift, x, y)
      End If

   End If
   
   pDraw
   Screen.MousePointer = vbDefault
   '
End Sub

Private Sub UserControl_OLECompleteDrag(Effect As Long)
   '
   'Debug.Print "OLECompleteDrag"
   Dim tItem As tBarItem
   Dim i As Long
   
   If (m_iDragBar &gt; 0) Then
      If Not (m_iDragBar = m_iSelBar) Then
         ' move this item to the newly selected bar,
         ' and place it at the appropriate position:
         LSet tItem = m_tBar(m_iSelBar).tItem(m_iDragItem)
         
         ' Remove from bar:
         fItemRemove m_tBar(m_iSelBar).lId, m_iDragItem
         
         ' add to next bar:
         Dim cT As cToolItem
         Set cT = fItemAdd(m_tBar(m_iDragBar).lId, tItem.sKey, ,
          tItem.sCaption, tItem.lIconIndex)
         cT.Enabled = tItem.bEnabled
         cT.ItemData = tItem.lItemData
         cT.Tag = tItem.sTag
         
      End If
   Else
      If Not (m_iDragItem = m_iDragOverItem) Then
         If (m_iDragOverItem &gt; 0) Then
            ' Bar is probably not sorted any more:
            If (m_tBar(m_iSelBar).bSorted) Then
               m_tBar(m_iSelBar).bSorted = False
            End If
            LSet tItem = m_tBar(m_iSelBar).tItem(m_iDragItem)
            If (m_iDragOverItem &gt; m_iDragItem) Then
               For i = m_iDragItem To m_iDragOverItem - 1
                  LSet m_tBar(m_iSelBar).tItem(i) = m_tBar(m_iSelBar).tItem(i +
                   1)
               Next i
               LSet m_tBar(m_iSelBar).tItem(m_iDragOverItem) = tItem
            Else
               For i = m_iDragItem To m_iDragOverItem + 1 Step -1
                  LSet m_tBar(m_iSelBar).tItem(i) = m_tBar(m_iSelBar).tItem(i -
                   1)
               Next i
               LSet m_tBar(m_iSelBar).tItem(m_iDragOverItem) = tItem
            End If
            pResize
         End If
      End If
   End If
   
   
   m_iDragBar = 0
   m_iDragOverItem = 0
   pDraw
   '
End Sub

Private Sub UserControl_OLEDragDrop(Data As DataObject, Effect As Long, Button
 As Integer, Shift As Integer, x As Single, y As Single)
   '
   'Debug.Print "OLEDragDrop"
   '
End Sub

Private Sub UserControl_OLEDragOver(Data As DataObject, Effect As Long, Button
 As Integer, Shift As Integer, x As Single, y As Single, State As Integer)
   '
   'Debug.Print "OLEDragOver"
   If (m_iBarCount &gt; 0) Then
      If (Data.GetFormat(tbbCfItemIdentifier)) Then
      
         ' what are we over:
         Dim tP As POINTAPI
         GetCursorPos tP
         ScreenToClient m_hWnd, tP
         
         ' first check client area:
         If (m_iSelBar &gt; 0) Then
            Dim i As Long
            Dim tR As RECT
            For i = 1 To m_tBar(m_iSelBar).lItemCount
               LSet tR = m_tBar(m_iSelBar).tItem(i).tR
               OffsetRect tR, 0, m_tBar(m_iSelBar).lOffset
               If (tR.Top &gt; m_tBar(m_iSelBar).tClientR.bottom) Then
                  Exit For
               ElseIf (tR.bottom &lt;= m_tBar(m_iSelBar).tClientR.Top) Then
                  ' ignore it
               Else
                  If Not (PtInRect(tR, tP.x, tP.y) = 0) Then
                     'Debug.Print "Got a Hit on ";
                      m_tBar(m_iSelBar).tItem(i).sCaption
                     If (tR.Top = m_tBar(m_iSelBar).tCaptionR.bottom) Then
                        If (m_tBar(m_iSelBar).lOffset &lt; 0) Then
                           If (m_lClickTime = &amp;HFFFFFFFF) Then
                              m_lClickTime = timeGetTime() + 500
                           Else
                              If (timeGetTime() - m_lClickTime &gt; 100) Then
                                 m_lClickTime = timeGetTime()
                                 pScrollIntoView i - 1
                              End If
                           End If
                        End If
                     End If
                     m_iDragBar = 0
                     If Not (m_iDragItem = i) Then
                        m_iDragOverItem = i
                        If (tR.bottom &gt; m_tBar(m_iSelBar).tCaptionR.bottom) Then
                           If (m_lClickTime = &amp;HFFFFFFFF) Then
                              m_lClickTime = timeGetTime() + 500
                           Else
                              If (timeGetTime() - m_lClickTime &gt; 100) Then
                                 m_lClickTime = timeGetTime()
                                 pScrollIntoView i
                              End If
                           End If
                        End If
                     Else
                        m_iDragOverItem = 0
                     End If
                     pDraw
                     Exit Sub
                  End If
               End If
            Next i
            
            ' Now check for the bars:
            For i = 1 To m_iBarCount
               If Not (PtInRect(m_tBar(i).tCaptionR, tP.x, tP.y) = 0) Then
                  m_lClickTime = &amp;HFFFFFFFF
                  m_iDragOverItem = 0
                  m_iDragBar = i
                  pDraw
                  Exit Sub
               End If
            Next i
            
         End If

      End If
      
      If (m_iDragOverItem &gt; 0) Or (m_iDragBar &gt; 0) Then
         m_iDragOverItem = 0
         m_iDragBar = 0
         pDraw
      End If
      
   End If
   '
End Sub

Private Sub UserControl_OLEStartDrag(Data As DataObject, AllowedEffects As Long)
   '
   AllowedEffects = vbDropEffectCopy
   
   Data.Clear
   Dim b() As Byte
   
   ' Item identifier:
   b = m_tBar(m_iSelBar).lId &amp; ":" &amp; m_tBar(m_iSelBar).tItem(m_iDragItem).lId
   Data.SetData b, tbbCfItemIdentifier
   
   ' Tag:
   b = m_tBar(m_iSelBar).tItem(m_iDragItem).sTag
   Data.SetData b, tbbCfItemTag
   
   ' Text:
   Data.SetData m_tBar(m_iSelBar).tItem(m_iDragItem).sCaption, vbCFText

   m_lClickTime = &amp;HFFFFFFFF
   '
End Sub

Private Sub UserControl_Paint()
   pDraw
End Sub

Private Sub UserControl_ReadProperties(PropBag As PropertyBag)
   
   pInitialise

   BackColor = PropBag.ReadProperty("BackColor", vbButtonFace)
   ForeColor = PropBag.ReadProperty("ForeColor", vbWindowText)
   Dim sFnt As New StdFont
   sFnt.Name = "Tahoma"
   sFnt.Size = 8.25
   Font = PropBag.ReadProperty("Font", sFnt)
   BorderStyle = PropBag.ReadProperty("BorderStyle", 0)
   ScaleMode = PropBag.ReadProperty("ScaleMode", vbTwips)

End Sub

Private Sub UserControl_Resize()
   pResize
End Sub

Private Sub UserControl_Terminate()
   
   m_tmr.Enabled = False
   Set m_cMemDC = Nothing
   m_hWnd = 0
   
   'Debug.Print "vbalToolBoxBarCtl:Terminate", ObjPtr(Me)
   
End Sub

Private Sub UserControl_WriteProperties(PropBag As PropertyBag)
   PropBag.WriteProperty "BackColor", BackColor, vbButtonFace
   PropBag.WriteProperty "ForeColor", ForeColor, vbWindowText
   Dim sFnt As New StdFont
   sFnt.Name = "Tahoma"
   sFnt.Size = 8.25
   PropBag.WriteProperty "Font", Font, sFnt
   PropBag.WriteProperty "BorderStyle", BorderStyle, 0
   PropBag.WriteProperty "ScaleMode", ScaleMode, vbTwips

End Sub
</pre><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p></td><td class="rightbar" valign="top" bgcolor="#C2BEB1">
<!-- No right bar content currently defined -->
</td></tr><tr class="footer"><td></td>
<td>
<p class="center"></p>
</td>
<td></td>
</tr><tr><td colspan="3"><hr /></td></tr><tr class="footer"><td valign="top"><a href="http://www.vbaccelerator.com/home/index.asp"><img width="125" height="25" src="../../../../../res/vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="http://www.vbaccelerator.com/home/index.asp">Home</a>&#160;.&#160;<a href="../../../../index.html">VB</a>&#160;.&#160;<a href="../../../index.html">Code</a>&#160;.&#160;<a href="../../index.html">Controls</a>&#160;.&#160;<a href="../index.html">ListBar</a>&#160;.&#160;<a href="article.html">vbAccelerator Visual Studio Style ToolBox ListBar</a>&#160;.&#160;<a href="VB5_ToolBox_ListBar_Full_Source.html">VB5 ToolBox ListBar Full Source</a>&#160;.&#160;vbalToolBoxBarCtl.ctl</p><br /><p class="nav"><a href="http://www.vbaccelerator.com/home/The_Site/Copyright/article.asp">Copyright</a> &#169; 2003 Steve McMahon <a href="mailto:steve@vbaccelerator.com">steve@vbaccelerator.com</a>.  All rights reserved.<br />Last Updated: 12 April 2003</p></td><td></td></tr></table>
</body>
<!-- Mirrored from www.vbaccelerator.com/home/VB/Code/Controls/ListBar/Visual_Studio_Style_ListBar/VB5_ToolBox_ListBar_Full_Source_zip_vbalToolBoxBarCtl_ctl.asp by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 Jun 2015 21:30:52 GMT -->
</html>