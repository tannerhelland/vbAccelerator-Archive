<html lang="en" >

<!-- Mirrored from www.vbaccelerator.com/home/VB/Code/Libraries/Subclassing/SSubTimer/article.asp by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 Jun 2015 20:46:24 GMT -->
<head>

<title>vbAccelerator - Subclassing Without The Crashes</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta name="AUTHOR" content="Steve McMahon" /><meta name="KEYWORDS" content=".NET, .NET Framework, C#, CSharp, VB, Visual Basic, VB5, VB6, Visual Basic, Active X, Controls, Components" /><meta name="DESCRIPTION" content="Prior to VB5, it was impossible to subclass a control without relying on a proprietary 
custom control. This greatly restricted what you could do if you wanted to play around with 
some of the neater customisation features - creating a new control was completely out, finding out 
in detail what was going on with menus was impossible and so on.The introduction of the AddressOf operator to VB5 now allows you to subclass, although 
it is not nearly as simple as it ought to be.The SSubTmr component is a more stable and consistent way of working with subclassing,
without some of the attendent difficulties. You can either use it as an external DLL to provide, or 
by including one module and one interface class, you can compile it directly into your application 
once you are happy the subclassing is working. SSubTmr is the basis for most of the VB controls
on this site.The component itself mostly uses the SubTimer.DLL component code from 
Bruce McKinney's excellent 'Hardcore Visual Basic' book, however it has a couple of 
very useful enhancements described in this article." /><link rel="stylesheet" href="../../../../../res/screen.css" media="SCREEN" /><link rel="stylesheet" href="../../../../../res/print.css" media="PRINT" /></head><body>
<table>
<tr class="adbar" bgcolor="#83726a"><tr class="footer"><td></td>
<td>
<p class="center">

<script type="text/javascript"><!--
google_ad_client = "pub-4690375644913255";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_channel ="";
google_ad_type = "text_image";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_url = "008000.html";
google_color_text = "000000";
//--></script>
<script type="text/javascript"
  src="../../../../../../../pagead2.googlesyndication.com/pagead/f.txt">
</script>
</p>
</td>
<td></td>
</tr></tr><tr class="navbar"><td><a href="http://www.vbaccelerator.com/home/index.asp"><img width="125" height="25" src="../../../../../res/vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="http://www.vbaccelerator.com/home/index.asp">Home</a>&#160;.&#160;<a href="../../../../index.html">VB</a>&#160;.&#160;<a href="../../../index.html">Code</a>&#160;.&#160;<a href="../../index.html">Libraries</a>&#160;.&#160;<a href="../index.html">Subclassing</a>&#160;.&#160;Subclassing Without The Crashes</p></td><td></td></tr><tr class="navbar"><td colspan="3"><hr /></td></tr><tr valign="top"><td class="sidebar"><img src="../../../../../res/download.png" width="125" height="21" alt="Downloads" /><p class="nav"><a href="VB5_Graduated_Title_Bar_Sample.html"><img src="../../../../../res/get.png" width="8" height="8" alt="Download Page" />VB5 Graduated Title Bar Sample</a> (44K)</p><p class="nav"><a href="VB5_Minimum_Form_Size_Demonstration.html"><img src="../../../../../res/get.png" width="8" height="8" alt="Download Page" />VB5 Minimum Form Size Demonstration</a> (9K)</p><p class="nav"><a href="VB5_SSubTmr_Binary.html"><img src="../../../../../res/get.png" width="8" height="8" alt="Download Page" />VB5 SSubTmr Binary</a> (11K)</p><p class="nav"><a href="VB5_SSubTmr_Source_Code.html"><img src="../../../../../res/get.png" width="8" height="8" alt="Download Page" />VB5 SSubTmr Source Code</a> (34K)</p><p /><p class="nav"><a href="VB6_Graduated_Title_Bar_Sample.html"><img src="../../../../../res/get.png" width="8" height="8" alt="Download Page" />VB6 Graduated Title Bar Sample</a> (38K)</p><p class="nav"><a href="VB6_Minimum_Form_Size_Demonstration.html"><img src="../../../../../res/get.png" width="8" height="8" alt="Download Page" />VB6 Minimum Form Size Demonstration</a> (8K)</p><p class="nav"><a href="VB6_SSubTmr_Binary.html"><img src="../../../../../res/get.png" width="8" height="8" alt="Download Page" />VB6 SSubTmr Binary</a> (11K)</p><p class="nav"><a href="VB6_SSubTmr_Source_Code.html"><img src="../../../../../res/get.png" width="8" height="8" alt="Download Page" />VB6 SSubTmr Source Code</a> (41K)</p><br /><br /><img src="../../../../../res/information.png" width="125" height="21" alt="Information" /><p class="nav">Article:17</p><p class="nav">&#160;&#160;<a href="http://www.vbaccelerator.com/linkto.asp?id=17&amp;type=Article&amp;title=Subclassing%20Without%20The%20Crashes">Link to this page</a></p><p class="nav">Applies To:</p><p class="nav">&#160;&#160;VB5</p><p class="nav">&#160;&#160;VB6</p><p class="nav">Author:</p><p class="nav">&#160;&#160;<a href="mailto:steve@vbaccelerator.com">Steve McMahon</a></p><br /><br /><img src="../../../../../res/bugTrak.png" width="125" height="21" alt="BugTrak System" />﻿<p class="nav"><a href="bugTrak.html">BugTrak</a></p><p class="nav"><a href="bugTrak.html#bugs"><img src="../../../../../res/btBug.png" width="16" height="16" alt="Bug" />&#160;Bugs:</a> 0 / 0</p><p class="nav"><a href="bugTrak.html#issues"><img src="../../../../../res/btIssue.png" width="16" height="16" alt="Issue" />&#160;Issues:</a> 1 / 1</p><p class="nav"><a href="bugTrak.html#questions"><img src="../../../../../res/btQuestion.png" width="16" height="16" alt="Question" />&#160;Questions:</a> 0 / 0</a></p><p class="nav">Updated:14 April 2003</p>
<br /><br /><img src="../../../../../res/updates.png" width="125" height="21" alt="Updates" /><p class="nav"><img src="../../../../../res/update.png" width="8" height="8" alt="Update" />26 Jan 2003<br /><p class="update">Fixed problem with multiple attach/detach calls, 
and added automatic detach for the <i>WM_DESTROY</i>
message.</p><p class="update">Refactored code for clarity.</p></p><p class="update"><a href="updates.html">Update History &gt;</a></p><br /><br /><img src="../../../../../res/related.png" width="125" height="21" alt="Related Items" />﻿<br /><br /><img src="../../../../../res/search.png" width="125" height="21" alt="Search" />
<!-- Search Google -->
<form method="GET" action="http://www.google.com/custom">
<a href="http://www.google.com/search"><img src="../../../../../../../www.google.com/logos/Logo_40wht.gif" alt="Google" /></A><br />
<input type="text" name="q" size="31" maxlength="255" value="" class="search" /><br />
<input type="submit" name="sa" value="Search Google" class="search" />
<input type="hidden" name="cof" value="T:black;LW:330;ALC:990000;L:http://www.vbaccelerator.com/images/accl9.gif;LC:660000;LH:66;BGC:white;AH:left;VLC:999966;S:http://vbaccelerator.com/;GALT:999966;AWFID:67c7759ff27e5395;" />
<input type="hidden" name="domains" value="vbaccelerator.com" /><br />
<p class="nav"><input type="radio" name="sitesearch" value="" />Search WWW<br /></p>
<p class="nav"><input type="radio" name="sitesearch" value="vbaccelerator.com" checked="true" />vbAccelerator<br /></p>
</FORM>
<!-- Search Google -->
<br /><br />

<a href="http://www.vbaccelerator.com/home/The_Site/NewSite/article.asp"><img src="../../../../../res/newsite.png" width="125" height="129" alt="The New Site" /></a>
<br /><br />
</td><td width="100%" valign="top"><h1>Subclassing Without The Crashes</h1><p class="splash">Add stable and reliable multi-object subclasses to your project.</p><img src="ssubtmr2.gif" alt="Still a Rather Sad Subclassing Graphic" width="255" height="154" /><p /><p>Prior to VB5, it was impossible to subclass a control without relying on a proprietary 
custom control. This greatly restricted what you could do if you wanted to play around with 
some of the neater customisation features - creating a new control was completely out, finding out 
in detail what was going on with menus was impossible and so on.</p><p>The introduction of the <i>AddressOf</i> operator to VB5 now allows you to subclass, although 
it is not nearly as simple as it ought to be.</p><p>The <i>SSubTmr</i> component is a more stable and consistent way of working with subclassing,
without some of the attendent difficulties. You can either use it as an external DLL to provide, or 
by including one module and one interface class, you can compile it directly into your application 
once you are happy the subclassing is working. SSubTmr is the basis for most of the VB controls
on this site.</p><p>The component itself mostly uses the <i>SubTimer.DLL</i> component code from 
Bruce McKinney's excellent "Hardcore Visual Basic" book, however it has a couple of 
very useful enhancements described in this article.</p><h2>The Problem With Subclassing</h2><p>If you develop ActiveX controls and intend to subclass or hook a window, you'll very 
quickly discover that doing it is not at all straightforward. A typical problem is that a 
control which works fine when there is a single instance on a form suddenly stops working 
or starts GPFing when you place two instances on the form. Why is this happening?</p><p>The AddressOf operator requires you to place the callback routine in a module 
(and most annoying this is too!). This module is shared between all instances of your control and 
therefore the variables and subroutines contained by that module are also shared.</p><p>To visualise the situation, consider a control which wants to know if its parent has changed size. 
To do this, you create a callback routine in a module to handle the <i>WndProc</i> callback. 
Then, you want to add this callback routine to the parent's window handle so you will be routed 
all the parent's messages. To add the callback, you change the parent's <i>GWL_WNDPROC</i> 
Window Long to the address of your <i>WndProc</i> function. This function returns a pointer 
to the previously installed <i>WndProc</i> function, which you must be sure to forward all 
messages to that you aren't fully handling yourself (otherwise you quickly find your control 
will do nothing or, more likely, prevent its container from doing anything!). When you remove 
an instance of your control, you need to put the old <i>WndProc</i> back again.</p><p>The following diagrams show how easy it is to end up with one control not functioning in this 
circumstance, because of the sharing of variables in the module:</p><p class="caption">With One Instance of Your Control</p><img src="subclsok.gif" width="265" height="91" alt="With a Single Instance of the Control, the Module Correctly Stores the old Window Procedure location" /><p class="caption">With Two Instances</p><img src="subclser.gif" width="267" height="137" alt="Two Instances of the Same Control share the same Module, so the Module stores the wrong Window Procedure!" /><p>You can correct this problem by storing a separate WndProc for each control instance that gets 
created. However, there is now a much more difficult problem to solve - how to make sure your control 
terminates correctly.</p><p>The WndProc function in the module receives all the messages, but you need to pass this information 
on to your UserControl for the object to do anything about the messages. Therefore the 
module needs to know about the instance of the control it wants to inform about the message. 
Since the module is shared between all instances of the UserControl in question, it will need 
to know which <i>hWnd</i> is associated with which UserControl instance, and also needs to be sure it 
only installs the WindowProc function for the same <i>hWnd</i> once.</p><p>You might think you can get around this by storing an array of references to UserControls in your 
WindowProc handler message, and when you receive a message, you then enumerate through your array 
and inform each item in turn. I tried this and there is a big downside. If your module holds a 
reference to any UserControl instance, it will not allow the UserControl object to be released 
until VB figures out that the reference has gone out of scope or if you set the object to nothing. 
However, unless you can arrange for the user of the control to call a method before the 
UserControl is destroyed, it is impossible for the reference to go out of scope!</p><p>Often the user of the control will forget to call this method, or will press the Stop button 
in VB IDE, or call End, the consequences being:</p><ul><li>The <i>UserControl_Terminate</i> event never fires (this only fires when there are no 
references to the UserControl instance)</li><li>.. Hence the UserControl never stops running</li><li>.... And so you never remove the WindowProc, which suddenly stops being valid because the 
container no longer exists....</li></ul><p>This is a very quick way to get a big and nasty GPF. Worse, this sort of thing sometimes 
works in design mode, but then when you build the OCX version all of a sudden you are getting 
'Control.OCX referenced memory at 2x4500E000. The memory could not be "read"'...</p><h2>Fixing It - Slimy Hacks and Neat Tips</h2><p>Two things you need to fix these problems are:</p><ul><li>Don't Store Direct References to Objects - Use a Slimy Hack Instead!</li><li>Use Window's built in database to store information against hWnds</li></ul><p>These are now described in turn.</p><h3>Don't Store Direct References to Objects - Use a Slimy Hack Instead!</h3><p>Whenever you store a reference to an object in VB, VB increments it's COM reference count for you.
This is great in the sense that it allows you not to worry about objects being invalid when you 
call them. However, its a massive pain if you have two objects which reference each other, because
the COM reference count can never go down to zero unless you can figure a way to manually inform
one or the other objects that they should terminate.  Luckily there is a great hack to work 
around this.</p><p>Instead you store a long pointer to an object. This allows you to get an object reference, 
but prevents the object's reference count being incremented. Obviously this will lead you into 
difficulties if the object goes out of scope before you make a call to the object being pointed to 
(GPF...) but when used carefully this is a great technique. Here is how you do it:</p><pre>
  ' All credit for this code to Bruce McKinney:
  Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" ( _
    lpvDest As Any, lpvSource As Any, ByVal cbCopy As Long)

  Private Property Get ObjectFromPtr(ByVal lPtr As Long) As Object
  Dim oThis As Object

    ' Turn the pointer into an illegal, uncounted interface
    CopyMemory oThis, lPtr, 4
    ' Do NOT hit the End button here! You will crash!
    ' Assign to legal reference
    Set ObjectFromPtr = oThis
    ' Still do NOT hit the End button here! You will still crash!
    ' Destroy the illegal reference
    CopyMemory oThis, 0&amp;, 4
    ' OK, hit the End button if you must--you'll probably still crash,
    ' but this will be your code rather than the uncounted reference!

  End Property

  Private Property Get PtrFromObject(ByRef oThis As Object) As Long

    ' Return the pointer to this object:
    PtrFromObject = ObjPtr(oThis)

  End Property
</pre><p>That gives the general picture of how to do it. You can improve matters by typing the variables 
of type <i>Object</i> to suit your particular application.</p><h3>Use Window's built in database to store information against a hWnd</h3><p>This is an excellent feature. Windows has functions which allow you to store as many long values 
as you want against a named field for a given hWnd. Here are the functions:</p><pre>
  Declare Function GetProp Lib "user32" Alias "GetPropA" _
    (ByVal hwnd As Long, ByVal lpString As String) As Long
  Declare Function SetProp Lib "user32" Alias "SetPropA" _
    (ByVal hwnd As Long, ByVal lpString As String, ByVal hData As Long) As Long
  Declare Function RemoveProp Lib "user32" Alias "RemovePropA" _
    (ByVal hwnd As Long, ByVal lpString As String) As Long
</pre><p>You use them like this:</p><pre>
  ' To set a property called 'NumberOfInstances' to 3 for a form:
  SetProp Me.hWnd, "NumberOfInstances", 3

  ' To get the 'NumberOfInstances' value:
  lNumber = GetProp(Me.hWnd, "NumberOfInstances")

  ' To delete the property when finished with it 
  ' (Windows does this automatically when the application is ended):
  RemoveProp Me.hWnd, "NumberOfInstances"
</pre><p>You can use these functions to store as much information as you want against a given hWnd, 
and this is a perfect place to store pointers to objects which your subclassed window proc is 
going to call to, not to mention the old window proc value.</p><h2>SSubTmr Implementation</h2><p>SSubTmr implements these techniques to produce a stable subclasser which you can use regardless 
of how many instances you have and how many controls want to attempt to subclass the same hWnd. 
The implementation is very similar to the SubTimer component from Hardcore Visual Basic, but with 
some improvements.</p><p>The subclassing consists of three parts:</p><ul><li>A bas module (subclass.bas) which contains the logic to associate object pointers with window 
handles, and manage the adding and removing of the subclassed proc.</li><li>An Interface, ISubClass.bas, defining the properties and methods which an object must support 
in order to take part in subclassing with subclass.bas. To ensure all these interfaces are present, 
subclass.bas will not accept any object which doesn't implement this interface.</li><li>A global class (GSubClass.Cls) which exposes functions to initiate and control the 
subclassing procedure.</li></ul><p>For reference, here are the window properties SSUBTMR uses to manage the subclassing process:</p><h3>C[hWnd]</h3><p>Stores the number of instances using the subclass. When the property is 0 and you add to the 
subclass, it installs the WindowProc. Subsequent additions just increment the counter and 
use the existing WindowProc. When items are removed, the count is decremented, until it gets 
to zero, when the WindowProc is removed again.</p><h3>[hWnd]#[Message]C</h3><p>The count of how many times the message [Message] is attached to the hWnd [hWnd]. This 
allows you to subclass the same message on the same hWnd more than once. For example, if a 
control wants to subclass it's parent, and you place two controls on the same parent, you need both 
controls to be able to receive that message.</p><h3>[hWnd]#[Message]#[Number]</h3><p>Stores a pointer to the object which wants to receive notification for the 
hWnd/Message combination.</p><h2>Differences between SSUBTMR and the Hardcore Visual Basic version</h2><p>There are five main differences between this component and the one provided with Hardcore Visual Basic:</p><ol><li><strong>Ability to subclass the same message for the same Window handle more than once</strong><br />
This allows you to produce controls which intercept the same message on the parent window handle. Note 
that there was a problem with this in the first release that is now fixed.</li><li><strong>Response to messages is configurable on a message by message basis</strong><br />
In the original SubTimer component you could specify which type of message response you wanted, 
but if you wanted to Pre-process some messages but Post-Process others you couldn't. This occurs 
because when the message response property is queried you don't know what the message it's 
querying for. This is resolved by the addition of a new <i>CurrentMessage</i> property which you can 
query in the <i>MsgResponse</i> event.</li><li><strong>You can change the wParam and lParam values when you return</strong><br />
In SubTimer, wParam and lParam are passed <i>ByVal</i> so you can't change them. Some window procedures 
ask you to modify the wParam and lParam (drawing a customised title bar is one of these) when you 
return. This is resolved by adding a new <i>CallOldWindowProc</i> method. Set the message response 
to <i>emrConsume</i> to eat the message, and then use this call to send your new wParam and lParam 
values to the calling <i>WindowProc</i>. </li><li><strong>Reduction in modules</strong><br />
To aid compiling SSubTmr directly into an EXE rather than using the DLL, the code has been moved 
around so the declares are localised to the modules that need them. To incorporate subclassing 
support into a project, just copy Subclass.bas and ISubClass.cls into your module and remove 
the reference to the SSubTmr.DLL component. (Warning: Don't do this until you've finished debugging, 
otherwise debugging can get to be seriously hard.)</li><li>Sorry, there isn't a fifth one.</li></ol><h2>Quick Start - How to Use SSUBTMR</h2><p>To quickly get started with subclassing, here is a simple example which demonstrates 
how to prevent a form from being resized smaller than a certain width and height. This is 
also available in the demonstration project download.</p><h3>Step 1</h3><p>Create a new Standard EXE project.</p><h3>Step 2</h3><p>Add a reference to SSubTmr.DLL. This appears in the references list as 
'Subclassing and Timer Assistant (with configurable message response, multi-control support + timer bug fix)'</p><h3>Step 3</h3><p>Implement the Subclassing interface:</p><p class="caption">In the declarations section, add the following code:</p><pre>
  Implements ISubClass
</pre><p class="caption">Make sure that the required interfaces are supported under the ISubClass section:</p><pre>
  Private Property Let ISubClass_MsgResponse(ByVal RHS As EMsgResponse) 
    ' This Property Let is not really needed! 
  End Property 

  Private Property Get ISubClass_MsgResponse() As EMsgResponse 
    ' This will tell you which message you are responding to: 
    Debug.Print CurrentMessage 
    ' Tell the subclasser what to do for this message (here we do all processing):
    ISubClass_MsgResponse = emrConsume 
  End Property 

  Private Function ISubClass_WindowProc( _
    ByVal hWnd As Long, ByVal iMsg As Long, ByVal wParam As Long, ByVal lParam As Long _ 
    ) As Long 
    Debug.Print "Got Message" 
  End Function
</pre><h3>Step 4</h3><p>Now you have a template for all subclassing projects, here is the code you need to 
prevent form resizing smaller than a certain size:</p><p class="caption">Declarations:</p><pre>

Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" ( _ 
    lpvDest As Any, lpvSource As Any, ByVal cbCopy As Long) 
Private Type POINTAPI 
    x As Long 
    y As Long 
End Type 
Private Type MINMAXINFO 
    ptReserved As POINTAPI 
    ptMaxSize As POINTAPI 
    ptMaxPosition As POINTAPI 
    ptMinTrackSize As POINTAPI 
    ptMaxTrackSize As POINTAPI
End Type
Private Const WM_GETMINMAXINFO = &amp;H24 
</pre><p class="caption">To start and stop subclassing:</p><pre>
Private Sub Form_Load() 
    AttachMessage Me, Me.hwnd, WM_GETMINMAXINFO 
End Sub 

Private Sub Form_QueryUnload(Cancel As Integer, UnloadMode As Integer) 
    DetachMessage Me, Me.hwnd, WM_GETMINMAXINFO
End Sub 
</pre><p class="caption">The code to handle the WM_GETMINMAXINFO message:</p><pre>
Private Function ISubclass_WindowProc( _
   ByVal hwnd As Long, ByVal iMsg As Long, _
   ByVal wParam As Long, ByVal lParam As Long) As Long 
Dim mmiT As MINMAXINFO 

    ' Copy parameter to local variable for processing 
    CopyMemory mmiT, ByVal lParam, LenB(mmiT) 
    
    ' Minimium width and height for sizing 
    mmiT.ptMinTrackSize.x = 128 
    mmiT.ptMinTrackSize.y = 128 
        
    ' Copy modified results back to parameter 
    CopyMemory ByVal lParam, mmiT, LenB(mmiT)

End Function
</pre><p>Another sample included in the demonstration shows how to create Windows graduated title bar effects 
like those in the image below:</p><img src="gradtbar.gif" alt="Graduated Title Bar Demo" width="319" height="86" /><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p>&#160;</p></td><td class="rightbar" valign="top" bgcolor="#C2BEB1">
<!-- No right bar content currently defined -->
</td></tr><tr class="footer"><td></td>
<td>
<p class="center"></p>
</td>
<td></td>
</tr><tr><td colspan="3"><hr /></td></tr><tr class="footer"><td valign="top"><a href="http://www.vbaccelerator.com/home/index.asp"><img width="125" height="25" src="../../../../../res/vbaccelerator.png" alt="vbAccelerator Logo" /></a></td><td valign="bottom"><p class="nav"><a href="http://www.vbaccelerator.com/home/index.asp">Home</a>&#160;.&#160;<a href="../../../../index.html">VB</a>&#160;.&#160;<a href="../../../index.html">Code</a>&#160;.&#160;<a href="../../index.html">Libraries</a>&#160;.&#160;<a href="../index.html">Subclassing</a>&#160;.&#160;Subclassing Without The Crashes</p><br /><p class="nav"><a href="http://www.vbaccelerator.com/home/The_Site/Copyright/article.asp">Copyright</a> &#169; 2003 Steve McMahon <a href="mailto:steve@vbaccelerator.com">steve@vbaccelerator.com</a>.  All rights reserved.<br />Last Updated: 26 January 2003</p></td><td></td></tr></table>
</body>
<!-- Mirrored from www.vbaccelerator.com/home/VB/Code/Libraries/Subclassing/SSubTimer/article.asp by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 Jun 2015 20:46:29 GMT -->
</html>
